{
  "language": "Solidity",
  "sources": {
    "contracts/core/VaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\ncontract VaultPriceFeed {\n\n    IPyth public pyth;\n    uint256 public validTime;\n    mapping(address => bytes32) public feedIds;\n    address public gov;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"VaultPriceFeed: forbidden\");\n        _;\n    }\n\n    constructor(address _pyth) {\n        pyth = IPyth(_pyth);\n        validTime = 3 seconds;\n        gov = msg.sender;\n    }\n\n    function getPrice(address _token, bool _maximise, bool _fresh) external view returns (uint256) {\n        PythStructs.Price memory _feed = pyth.getPriceUnsafe(feedIds[_token]);\n        require(_feed.price > 0, \"VaultPriceFeed: price not available\");\n        if (_fresh && block.timestamp > _feed.publishTime) \n            require(block.timestamp - _feed.publishTime <= validTime, \"VaultPriceFeed: price too old\");\n\n        uint256 _price = abs(_feed.price);\n        uint256 _confidence = uint256(_feed.conf);\n        uint256 _exponent = 30 - abs(_feed.expo);\n\n        _price = _maximise ? _price + _confidence : _price - _confidence;\n        return _price * 10 ** _exponent;\n    }\n\n    function latestTime(address _token) external view returns (uint256 _diff) {\n        PythStructs.Price memory _feed = pyth.getPriceUnsafe(feedIds[_token]);\n        _diff = block.timestamp - _feed.publishTime;\n    }\n\n    function getUpdateFee(bytes[] calldata _updateData) external view returns (uint256){\n        return pyth.getUpdateFee(_updateData);\n    }\n\n    function updatePriceFeeds(bytes[] calldata _priceData) external payable {\n        pyth.updatePriceFeeds{value : msg.value}(_priceData);\n    }\n\n    function setPyth(address _pyth) external onlyGov {\n        pyth = IPyth(_pyth);\n    }\n\n    function setValidTime(uint256 _validTime) external onlyGov {\n        validTime = _validTime;\n    }\n\n    function setFeedIds(address[] calldata _tokens, bytes32[] calldata _feedIds) external onlyGov {\n        require(_tokens.length == _feedIds.length, \"VaultPriceFeed: invalid feedIds\");\n        for (uint256 i = 0; i < _tokens.length; i++)\n            feedIds[_tokens[i]] = _feedIds[i];\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : - n);\n        }\n    }\n\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when a batch price update is processed successfully.\n    /// @param chainId ID of the source chain that the batch price update comes from.\n    /// @param sequenceNumber Sequence number of the batch price update.\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPyth.sol\";\nimport \"./PythErrors.sol\";\n\nabstract contract AbstractPyth is IPyth {\n    /// @notice Returns the price feed with given id.\n    /// @dev Reverts if the price does not exist.\n    /// @param id The Pyth Price Feed ID of which to fetch the PriceFeed.\n    function queryPriceFeed(\n        bytes32 id\n    ) public view virtual returns (PythStructs.PriceFeed memory priceFeed);\n\n    /// @notice Returns true if a price feed with the given id exists.\n    /// @param id The Pyth Price Feed ID of which to check its existence.\n    function priceFeedExists(\n        bytes32 id\n    ) public view virtual returns (bool exists);\n\n    function getValidTimePeriod()\n        public\n        view\n        virtual\n        override\n        returns (uint validTimePeriod);\n\n    function getPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getEmaPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getEmaPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.price;\n    }\n\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.emaPrice;\n    }\n\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getEmaPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function diff(uint x, uint y) internal pure returns (uint) {\n        if (x > y) {\n            return x - y;\n        } else {\n            return y - x;\n        }\n    }\n\n    // Access modifier is overridden to public to be able to call it locally.\n    function updatePriceFeeds(\n        bytes[] calldata updateData\n    ) public payable virtual override;\n\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable virtual override {\n        if (priceIds.length != publishTimes.length)\n            revert PythErrors.InvalidArgument();\n\n        for (uint i = 0; i < priceIds.length; i++) {\n            if (\n                !priceFeedExists(priceIds[i]) ||\n                queryPriceFeed(priceIds[i]).price.publishTime < publishTimes[i]\n            ) {\n                updatePriceFeeds(updateData);\n                return;\n            }\n        }\n\n        revert PythErrors.NoFreshUpdate();\n    }\n\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    )\n        external\n        payable\n        virtual\n        override\n        returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythErrors.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nlibrary PythErrors {\n    // Function arguments are invalid (e.g., the arguments lengths mismatch)\n    error InvalidArgument();\n    // Update data is coming from an invalid data source.\n    error InvalidUpdateDataSource();\n    // Update data is invalid (e.g., deserialization error)\n    error InvalidUpdateData();\n    // Insufficient fee is paid to the method.\n    error InsufficientFee();\n    // There is no fresh update, whereas expected fresh updates.\n    error NoFreshUpdate();\n    // There is no price feed found within the given range or it does not exists.\n    error PriceFeedNotFoundWithinRange();\n    // Price feed not found or it is not pushed on-chain yet.\n    error PriceFeedNotFound();\n    // Requested price is stale.\n    error StalePrice();\n    // Given message is not a valid Wormhole VAA.\n    error InvalidWormholeVaa();\n    // Governance message is invalid (e.g., deserialization error).\n    error InvalidGovernanceMessage();\n    // Governance message is not for this contract.\n    error InvalidGovernanceTarget();\n    // Governance message is coming from an invalid data source.\n    error InvalidGovernanceDataSource();\n    // Governance message is old.\n    error OldGovernanceMessage();\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/MockPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./AbstractPyth.sol\";\nimport \"./PythStructs.sol\";\nimport \"./PythErrors.sol\";\n\ncontract MockPyth is AbstractPyth {\n    mapping(bytes32 => PythStructs.PriceFeed) priceFeeds;\n    uint64 sequenceNumber;\n\n    uint singleUpdateFeeInWei;\n    uint validTimePeriod;\n\n    constructor(uint _validTimePeriod, uint _singleUpdateFeeInWei) {\n        singleUpdateFeeInWei = _singleUpdateFeeInWei;\n        validTimePeriod = _validTimePeriod;\n    }\n\n    function queryPriceFeed(\n        bytes32 id\n    ) public view override returns (PythStructs.PriceFeed memory priceFeed) {\n        if (priceFeeds[id].id == 0) revert PythErrors.PriceFeedNotFound();\n        return priceFeeds[id];\n    }\n\n    function priceFeedExists(bytes32 id) public view override returns (bool) {\n        return (priceFeeds[id].id != 0);\n    }\n\n    function getValidTimePeriod() public view override returns (uint) {\n        return validTimePeriod;\n    }\n\n    // Takes an array of encoded price feeds and stores them.\n    // You can create this data either by calling createPriceFeedData or\n    // by using web3.js or ethers abi utilities.\n    function updatePriceFeeds(\n        bytes[] calldata updateData\n    ) public payable override {\n        uint requiredFee = getUpdateFee(updateData);\n        if (msg.value < requiredFee) revert PythErrors.InsufficientFee();\n\n        // Chain ID is id of the source chain that the price update comes from. Since it is just a mock contract\n        // We set it to 1.\n        uint16 chainId = 1;\n\n        for (uint i = 0; i < updateData.length; i++) {\n            PythStructs.PriceFeed memory priceFeed = abi.decode(\n                updateData[i],\n                (PythStructs.PriceFeed)\n            );\n\n            uint lastPublishTime = priceFeeds[priceFeed.id].price.publishTime;\n\n            if (lastPublishTime < priceFeed.price.publishTime) {\n                // Price information is more recent than the existing price information.\n                priceFeeds[priceFeed.id] = priceFeed;\n                emit PriceFeedUpdate(\n                    priceFeed.id,\n                    uint64(lastPublishTime),\n                    priceFeed.price.price,\n                    priceFeed.price.conf\n                );\n            }\n        }\n\n        // In the real contract, the input of this function contains multiple batches that each contain multiple prices.\n        // This event is emitted when a batch is processed. In this mock contract we consider there is only one batch of prices.\n        // Each batch has (chainId, sequenceNumber) as it's unique identifier. Here chainId is set to 1 and an increasing sequence number is used.\n        emit BatchPriceFeedUpdate(chainId, sequenceNumber);\n        sequenceNumber += 1;\n    }\n\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) public view override returns (uint feeAmount) {\n        return singleUpdateFeeInWei * updateData.length;\n    }\n\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable override returns (PythStructs.PriceFeed[] memory feeds) {\n        uint requiredFee = getUpdateFee(updateData);\n        if (msg.value < requiredFee) revert PythErrors.InsufficientFee();\n\n        feeds = new PythStructs.PriceFeed[](priceIds.length);\n\n        for (uint i = 0; i < priceIds.length; i++) {\n            for (uint j = 0; j < updateData.length; j++) {\n                feeds[i] = abi.decode(updateData[j], (PythStructs.PriceFeed));\n\n                if (feeds[i].id == priceIds[i]) {\n                    uint publishTime = feeds[i].price.publishTime;\n                    if (\n                        minPublishTime <= publishTime &&\n                        publishTime <= maxPublishTime\n                    ) {\n                        break;\n                    } else {\n                        feeds[i].id = 0;\n                    }\n                }\n            }\n\n            if (feeds[i].id != priceIds[i])\n                revert PythErrors.PriceFeedNotFoundWithinRange();\n        }\n    }\n\n    function createPriceFeedUpdateData(\n        bytes32 id,\n        int64 price,\n        uint64 conf,\n        int32 expo,\n        int64 emaPrice,\n        uint64 emaConf,\n        uint64 publishTime\n    ) public pure returns (bytes memory priceFeedData) {\n        PythStructs.PriceFeed memory priceFeed;\n\n        priceFeed.id = id;\n\n        priceFeed.price.price = price;\n        priceFeed.price.conf = conf;\n        priceFeed.price.expo = expo;\n        priceFeed.price.publishTime = publishTime;\n\n        priceFeed.emaPrice.price = emaPrice;\n        priceFeed.emaPrice.conf = emaConf;\n        priceFeed.emaPrice.expo = expo;\n        priceFeed.emaPrice.publishTime = publishTime;\n\n        priceFeedData = abi.encode(priceFeed);\n    }\n}\n"
    },
    "contracts/mock/PythContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@pythnetwork/pyth-sdk-solidity/MockPyth.sol\";\n\ncontract PythContract is MockPyth {\n\n    constructor() MockPyth(60, 1) {}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "mode": "3"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.methodIdentifiers",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}