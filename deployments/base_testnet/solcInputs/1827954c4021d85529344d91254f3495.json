{
  "language": "Solidity",
  "sources": {
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ncontract Governable {\n    address public gov;\n    constructor() public {\n        gov = msg.sender;\n    }\n    modifier onlyGov() {\n        require(msg.sender == gov, \"Governable: forbidden\");\n        _;\n    }\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n}"
    },
    "contracts/access/interfaces/IAdmin.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\ninterface IAdmin {\n    function setAdmin(address _admin) external;\n}\n"
    },
    "contracts/core/BasePositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./settings/BasePositionManagerSettings.sol\";\n\ncontract BasePositionManager is BasePositionManagerSettings {\n\n    constructor(address _vault, address _router, address _shortsTracker, address _weth, uint256 _depositFee) public {\n        vault = _vault;\n        router = _router;\n        weth = _weth;\n        depositFee = _depositFee;\n        shortsTracker = _shortsTracker;\n        admin = msg.sender;\n    }\n\n    function withdrawFees(address _token, address _receiver) external onlyAdmin {\n        uint256 amount = feeReserves[_token];\n        if (amount == 0) {return;}\n        feeReserves[_token] = 0;\n        IERC20(_token).safeTransfer(_receiver, amount);\n        emit Events.WithdrawFees(_token, _receiver, amount);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount) external onlyGov {\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    function sendValue(address payable _receiver, uint256 _amount) external onlyGov {\n        _receiver.sendValue(_amount);\n    }\n\n    function _preChargeFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _paid) internal {\n        if (minLiquidationFee == 0)\n            return;\n        (bool exist, bytes32 key) = IVault(vault).isPositionExist(_account, _collateralToken, _indexToken, _isLong);\n        if (!exist) {\n            uint256 liqFee = msg.value - _paid;\n            require(liqFee >= minLiquidationFee, Errors.POSITIONMANAGER_INSUFFICIENT_FEE);\n            liquidationFees[key] = liqFee;\n            _transferInETH(liqFee);\n        }\n    }\n\n    function _payLiquidator(address _account, address _collateralToken, address _indexToken, bool _isLong, address payable _feeReceiver) internal {\n        (bool exist, bytes32 key) = IVault(vault).isPositionExist(_account, _collateralToken, _indexToken, _isLong);\n        uint256 _payAmount = liquidationFees[key];\n        if (!exist && _payAmount > 0) {\n            liquidationFees[key] = 0;\n            _transferOutETH(_payAmount, _feeReceiver);\n        }\n    }\n}\n"
    },
    "contracts/core/BasePriceConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IVaultPriceFeed.sol\";\n\ncontract BasePriceConsumer {\n\n    IVault internal _IVault;\n\n    constructor(address _vault) public {\n        _IVault = IVault(_vault);\n    }\n\n    function _update(bytes[] calldata _updateData) internal returns (uint256 _fee) {\n        if (_updateData.length == 0) return 0;\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(_IVault.priceFeed());\n        _fee = priceFeed.getUpdateFee(_updateData);\n        priceFeed.updatePriceFeeds{value : _fee}(_updateData);\n    }\n\n}\n"
    },
    "contracts/core/interfaces/IBasePositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IBasePositionManager {\n    function maxGlobalLongSizes(address _token) external view returns (uint256);\n    function maxGlobalShortSizes(address _token) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IOrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IOrderBook {\n\n    function getIncreaseOrder(address _account, uint256 _orderIndex) external view returns (\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n\n    function getDecreaseOrder(address _account, uint256 _orderIndex) external view returns (\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n\n    function executeDecreaseOrder(address, uint256, address payable) external;\n    function executeIncreaseOrder(address, uint256, address payable) external;\n}\n"
    },
    "contracts/core/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IRouter {\n    function addPlugin(address _plugin) external;\n    function pluginTransfer(address _token, address _account, address _receiver, uint256 _amount) external;\n    function pluginIncreasePosition(\n        address _account, address _collateralToken,\n        address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n    function pluginDecreasePosition(\n        address _account, address _collateralToken,\n        address _indexToken, uint256 _collateralDelta,\n        uint256 _sizeDelta, bool _isLong, address _receiver) external returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IShortsTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IShortsTracker {\n    function isGlobalShortDataReady() external view returns (bool);\n    function globalShortAveragePrices(address _token) external view returns (uint256);\n    function getNextGlobalShortData(\n        address _account, address _collateralToken,\n        address _indexToken, uint256 _nextPrice,\n        uint256 _sizeDelta, bool _isIncrease) external view returns (uint256, uint256);\n    function updateGlobalShortData(\n        address _account, address _collateralToken,\n        address _indexToken, bool _isLong,\n        uint256 _sizeDelta, uint256 _markPrice, bool _isIncrease) external;\n}"
    },
    "contracts/core/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./IVaultUtils.sol\";\ninterface IVault {\n    function withdrawFees(address _token, address _receiver) external returns (uint256);\n    function directPoolDeposit(address _token) external;\n    function buyZKUSD(address _token, address _receiver) external returns (uint256);\n    function sellZKUSD(address _token, address _receiver) external returns (uint256);\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external returns (uint256);\n    function increasePosition(\n        address _account, address _collateralToken,\n        address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n    function decreasePosition(\n        address _account, address _collateralToken,\n        address _indexToken, uint256 _collateralDelta,\n        uint256 _sizeDelta, bool _isLong, address _receiver) external returns (uint256);\n    function validateLiquidation(\n        address _account, address _collateralToken,\n        address _indexToken, bool _isLong, bool _raise) external view returns (uint256, uint256);\n    function liquidatePosition(\n        address _account, address _collateralToken,\n        address _indexToken, bool _isLong, address _feeReceiver) external returns (uint256);\n\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);\n    function priceFeed() external view returns (address);\n    function fundingRateFactor() external view returns (uint256);\n    function stableFundingRateFactor() external view returns (uint256);\n    function cumulativeFundingRates(address _token) external view returns (uint256);\n    function getNextFundingRate(address _token) external view returns (uint256);\n    function getFeeBasisPoints(\n        address _token, uint256 _zkusdDelta,\n        uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) external view returns (uint256);\n    function liquidationFeeUsd() external view returns (uint256);\n    function taxBasisPoints() external view returns (uint256);\n    function stableTaxBasisPoints() external view returns (uint256);\n    function mintBurnFeeBasisPoints() external view returns (uint256);\n    function swapFeeBasisPoints() external view returns (uint256);\n    function stableSwapFeeBasisPoints() external view returns (uint256);\n    function marginFeeBasisPoints() external view returns (uint256);\n    function allWhitelistedTokensLength() external view returns (uint256);\n    function allWhitelistedTokens(uint256) external view returns (address);\n    function whitelistedTokens(address _token) external view returns (bool);\n    function stableTokens(address _token) external view returns (bool);\n    function shortableTokens(address _token) external view returns (bool);\n    function equityTokens(address _token) external view returns (bool);\n    function feeReserves(address _token) external view returns (uint256);\n    function globalShortSizes(address _token) external view returns (uint256);\n    function globalShortAveragePrices(address _token) external view returns (uint256);\n    function maxGlobalShortSizes(address _token) external view returns (uint256);\n    function tokenDecimals(address _token) external view returns (uint256);\n    function tokenWeights(address _token) external view returns (uint256);\n    function guaranteedUsd(address _token) external view returns (uint256);\n    function poolAmounts(address _token) external view returns (uint256);\n    function bufferAmounts(address _token) external view returns (uint256);\n    function reservedAmounts(address _token) external view returns (uint256);\n    function zkusdAmounts(address _token) external view returns (uint256);\n    function maxZkusdAmounts(address _token) external view returns (uint256);\n    function getRedemptionAmount(address _token, uint256 _zkusdAmount) external view returns (uint256);\n    function getMaxPrice(address _token) external view returns (uint256);\n    function getMinPrice(address _token) external view returns (uint256);\n    function getDelta(\n        address _indexToken, uint256 _size,\n        uint256 _averagePrice, bool _isLong, uint256 _lastIncreasedTime) external view returns (bool, uint256);\n    function getPosition(\n        address _account, address _collateralToken,\n        address _indexToken, bool _isLong) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);\n    function isPositionExist(address _account, address _collateralToken, address _indexToken, bool _isLong) external view returns (bool, bytes32);\n    function isInitialized() external view returns (bool);\n    function isSwapEnabled() external view returns (bool);\n    function isLeverageEnabled() external view returns (bool);\n    function router() external view returns (address);\n    function zkusd() external view returns (address);\n    function gov() external view returns (address);\n    function whitelistedTokenCount() external view returns (uint256);\n    function maxLeverage() external view returns (uint256);\n    function minProfitTime() external view returns (uint256);\n    function hasDynamicFees() external view returns (bool);\n    function fundingInterval() external view returns (uint256);\n    function totalTokenWeights() external view returns (uint256);\n    function getTargetZkusdAmount(address _token) external view returns (uint256);\n    function inManagerMode() external view returns (bool);\n    function inPrivateLiquidationMode() external view returns (bool);\n    function maxGasPrice() external view returns (uint256);\n    function approvedRouters(address _account, address _router) external view returns (bool);\n    function isLiquidator(address _account) external view returns (bool);\n    function isManager(address _account) external view returns (bool);\n    function minProfitBasisPoints(address _token) external view returns (uint256);\n    function tokenBalances(address _token) external view returns (uint256);\n    function lastFundingTimes(address _token) external view returns (uint256);\n\n    function setMaxLeverage(uint256 _maxLeverage) external;\n    function setInManagerMode(bool _inManagerMode) external;\n    function setManager(address _manager, bool _isManager) external;\n    function setIsSwapEnabled(bool _isSwapEnabled) external;\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external;\n    function setMaxGasPrice(uint256 _maxGasPrice) external;\n    function setZkusdAmount(address _token, uint256 _amount) external;\n    function setBufferAmount(address _token, uint256 _amount) external;\n    function setMaxGlobalShortSize(address _token, uint256 _amount) external;\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;\n    function setLiquidator(address _liquidator, bool _isActive) external;\n    function setFundingRate(\n        uint256 _fundingInterval, uint256 _fundingRateFactor,\n        uint256 _stableFundingRateFactor) external;\n    function setFees(\n        uint256 _taxBasisPoints, uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints, uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints, uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd, uint256 _minProfitTime, bool _hasDynamicFees) external;\n\n    function setTokenConfig(\n        address _token, uint256 _tokenDecimals,\n        uint256 _redemptionBps, uint256 _minProfitBps,\n        uint256 _maxZkusdAmount, bool _isStable,\n        bool _isShortable, bool _isEquity) external;\n    function clearTokenConfig(address _token) external;\n    function setMinProfitTime(uint256 _minProfitTime) external;\n    function setPriceFeed(address _priceFeed) external;\n    function setVaultUtils(IVaultUtils _vaultUtils) external;\n    function setError(uint256 _errorCode, string calldata _error) external;\n    function setAllowStableEquity(bool _allowStaleEquityPrice) external;\n    function setZusd(address _zusd) external;\n}\n"
    },
    "contracts/core/interfaces/IVaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface IVaultPriceFeed {\n\n    function getPrice(address _token, bool _includeConf, bool _maximise, bool _fresh) external view returns (uint256);\n    function getUpdateFee(bytes[] calldata _updateData) external view returns (uint256);\n    function updatePriceFeeds(bytes[] calldata _priceData) external payable;\n}\n"
    },
    "contracts/core/interfaces/IVaultUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IVaultUtils {\n    function updateCumulativeFundingRate(\n        address _collateralToken, address _indexToken) external returns (bool);\n    function validateIncreasePosition(\n        address _account, address _collateralToken,\n        address _indexToken, uint256 _sizeDelta, bool _isLong) external view;\n    function validateDecreasePosition(\n        address _account, address _collateralToken,\n        address _indexToken, uint256 _collateralDelta,\n        uint256 _sizeDelta, bool _isLong, address _receiver) external view;\n    function validateLiquidation(\n        address _account, address _collateralToken,\n        address _indexToken, bool _isLong, bool _raise) external view returns (uint256, uint256);\n    function getEntryFundingRate(\n        address _collateralToken, address _indexToken, bool _isLong) external view returns (uint256);\n    function getPositionFee(\n        address _account, address _collateralToken,\n        address _indexToken, bool _isLong, uint256 _sizeDelta) external view returns (uint256);\n    function getFundingFee(\n        address _account, address _collateralToken,\n        address _indexToken, bool _isLong,\n        uint256 _size, uint256 _entryFundingRate) external view returns (uint256);\n    function getBuyZkusdFeeBasisPoints(\n        address _token, uint256 _zkusdAmount) external view returns (uint256);\n    function getSellZkusdFeeBasisPoints(\n        address _token, uint256 _zkusdAmount) external view returns (uint256);\n    function getSwapFeeBasisPoints(\n        address _tokenIn, address _tokenOut, uint256 _zkusdAmount) external view returns (uint256);\n    function getFeeBasisPoints(\n        address _token, uint256 _zkusdDelta,\n        uint256 _feeBasisPoints, uint256 _taxBasisPoints,\n        bool _increment) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IZkdlpManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IZkdlpManager {\n    function zkUsd() external view returns (address);\n    function cooldownDuration() external returns (uint256);\n    function getAumInZkusd(bool maximise) external view returns (uint256);\n    function lastAddedAt(address _account) external returns (uint256);\n//    function addLiquidity(\n//        address _token, uint256 _amount,\n//        uint256 _minZkusd, uint256 _minZkdlp) external returns (uint256);\n    function addLiquidityForAccount(\n        address _fundingAccount, address _account,\n        address _token, uint256 _amount,\n        uint256 _minZkusd, uint256 _minZkdlp) external returns (uint256);\n//    function removeLiquidity(\n//        address _tokenOut, uint256 _zkdlpAmount,\n//        uint256 _minOut, address _receiver) external returns (uint256);\n    function removeLiquidityForAccount(\n        address _account, address _tokenOut,\n        uint256 _zkdlpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n}\n"
    },
    "contracts/core/OrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\nimport \"./settings/OrderBookSettings.sol\";\nimport \"./interfaces/IVaultPriceFeed.sol\";\n\ncontract OrderBook is OrderBookSettings {\n    constructor(address _router, address _vault, address _weth, address _zkusd, uint256 _minExecutionFee) public {\n        router = _router;\n        vault = _vault;\n        weth = _weth;\n        zkusd = _zkusd;\n        minExecutionFee = _minExecutionFee;\n        gov = msg.sender;\n    }\n    receive() external payable {\n        require(msg.sender == weth, Errors.ORDERBOOK_INVALID_SENDER);\n    }\n    function _update(bytes[] memory _updateData) internal returns (uint256 _fee) {\n        if (_updateData.length == 0) return 0;\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(IVault(vault).priceFeed());\n        _fee = priceFeed.getUpdateFee(_updateData);\n        priceFeed.updatePriceFeeds{value : _fee}(_updateData);\n    }\n\n    /* public */\n    function updateIncreaseOrder(uint256 _orderIndex, uint256 _sizeDelta, uint256 _triggerPrice, bool _triggerAboveThreshold) external nonReentrant {\n        IncreaseOrder storage order = increaseOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        order.triggerPrice = _triggerPrice;\n        order.triggerAboveThreshold = _triggerAboveThreshold;\n        order.sizeDelta = _sizeDelta;\n\n        emit Events.UpdateIncreaseOrder(\n            msg.sender,\n            _orderIndex,\n            order.collateralToken,\n            order.indexToken,\n            order.isLong,\n            _sizeDelta,\n            _triggerPrice,\n            _triggerAboveThreshold\n        );\n    }\n    function cancelIncreaseOrder(uint256 _orderIndex) public nonReentrant {\n        IncreaseOrder memory order = increaseOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n        delete increaseOrders[msg.sender][_orderIndex];\n        if (order.purchaseToken == weth) {\n            _transferOutETH(order.executionFee.add(order.purchaseTokenAmount), msg.sender);\n        } else {\n            IERC20(order.purchaseToken).safeTransfer(msg.sender, order.purchaseTokenAmount);\n            _transferOutETH(order.executionFee, msg.sender);\n        }\n        emit Events.CancelIncreaseOrder(\n            order.account,\n            _orderIndex,\n            order.purchaseToken,\n            order.purchaseTokenAmount,\n            order.collateralToken,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee\n        );\n    }\n    function executeIncreaseOrder(address _address, uint256 _orderIndex, address payable _feeReceiver) override external nonReentrant {\n        IncreaseOrder memory order = increaseOrders[_address][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n        // increase long should use max price\n        // increase short should use min price\n        (uint256 currentPrice,) = validatePositionOrderPrice(\n            order.triggerAboveThreshold,\n            order.triggerPrice,\n            order.indexToken,\n            order.isLong,\n            true\n        );\n        delete increaseOrders[_address][_orderIndex];\n        IERC20(order.purchaseToken).safeTransfer(vault, order.purchaseTokenAmount);\n        if (order.purchaseToken != order.collateralToken) {\n            address[] memory path = new address[](2);\n            path[0] = order.purchaseToken;\n            path[1] = order.collateralToken;\n            uint256 amountOut = _swap(path, 0, address(this));\n            IERC20(order.collateralToken).safeTransfer(vault, amountOut);\n        }\n        IRouter(router).pluginIncreasePosition(order.account, order.collateralToken, order.indexToken, order.sizeDelta, order.isLong);\n        // pay executor\n        _transferOutETH(order.executionFee, _feeReceiver);\n        emit Events.ExecuteIncreaseOrder(\n            order.account,\n            _orderIndex,\n            order.purchaseToken,\n            order.purchaseTokenAmount,\n            order.collateralToken,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee,\n            currentPrice\n        );\n    }\n\n    function updateDecreaseOrder(uint256 _orderIndex, uint256 _collateralDelta, uint256 _sizeDelta, uint256 _triggerPrice, bool _triggerAboveThreshold) external nonReentrant {\n        DecreaseOrder storage order = decreaseOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n        order.triggerPrice = _triggerPrice;\n        order.triggerAboveThreshold = _triggerAboveThreshold;\n        order.sizeDelta = _sizeDelta;\n        order.collateralDelta = _collateralDelta;\n\n        emit Events.UpdateDecreaseOrder(\n            msg.sender,\n            _orderIndex,\n            order.collateralToken,\n            _collateralDelta,\n            order.indexToken,\n            _sizeDelta,\n            order.isLong,\n            _triggerPrice,\n            _triggerAboveThreshold\n        );\n    }\n    function cancelDecreaseOrder(uint256 _orderIndex) public nonReentrant {\n        DecreaseOrder memory order = decreaseOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n        delete decreaseOrders[msg.sender][_orderIndex];\n        _transferOutETH(order.executionFee, msg.sender);\n        emit Events.CancelDecreaseOrder(\n            order.account,\n            _orderIndex,\n            order.collateralToken,\n            order.collateralDelta,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee\n        );\n    }\n    function executeDecreaseOrder(address _address, uint256 _orderIndex, address payable _feeReceiver) override external nonReentrant {\n        DecreaseOrder memory order = decreaseOrders[_address][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n        // decrease long should use min price\n        // decrease short should use max price\n        (uint256 currentPrice,) = validatePositionOrderPrice(\n            order.triggerAboveThreshold,\n            order.triggerPrice,\n            order.indexToken,\n            !order.isLong,\n            true\n        );\n        delete decreaseOrders[_address][_orderIndex];\n        uint256 amountOut = IRouter(router).pluginDecreasePosition(\n            order.account,\n            order.collateralToken,\n            order.indexToken,\n            order.collateralDelta,\n            order.sizeDelta,\n            order.isLong,\n            address(this)\n        );\n        // transfer released collateral to user\n        // if (order.collateralToken == weth) _transferOutETH(amountOut, payable(order.account)); else\n        IERC20(order.collateralToken).safeTransfer(order.account, amountOut);\n        // pay executor\n        _transferOutETH(order.executionFee, _feeReceiver);\n        emit Events.ExecuteDecreaseOrder(\n            order.account,\n            _orderIndex,\n            order.collateralToken,\n            order.collateralDelta,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee,\n            currentPrice\n        );\n    }\n\n    function cancelMultiple(uint256[] memory _increaseOrderIndexes, uint256[] memory _decreaseOrderIndexes) external {\n        for (uint256 i = 0; i < _increaseOrderIndexes.length; i++) {\n            cancelIncreaseOrder(_increaseOrderIndexes[i]);\n        }\n        for (uint256 i = 0; i < _decreaseOrderIndexes.length; i++) {\n            cancelDecreaseOrder(_decreaseOrderIndexes[i]);\n        }\n    }\n\n    /* internal */\n    function _transferInETH() private {\n        if (msg.value != 0)\n            IWETH(weth).deposit{value: msg.value}();\n    }\n    function _transferOutETH(uint256 _amountOut, address payable _receiver) private {\n        IWETH(weth).withdraw(_amountOut);\n        (bool sent,) = _receiver.call{value : _amountOut}(\"\");\n        require(sent, \"OrderBook: failed to send ETH\");\n    }\n    function _swap(address[] memory _path, uint256 _minOut, address _receiver) private returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        if (_path.length == 3) {\n            uint256 midOut = _vaultSwap(_path[0], _path[1], 0, address(this));\n            IERC20(_path[1]).safeTransfer(vault, midOut);\n            return _vaultSwap(_path[1], _path[2], _minOut, _receiver);\n        }\n\n        revert(\"OrderBook: invalid _path.length\");\n    }\n    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) private returns (uint256) {\n        uint256 amountOut;\n\n        if (_tokenOut == zkusd) {// buyZKUSD\n            amountOut = IVault(vault).buyZKUSD(_tokenIn, _receiver);\n        } else if (_tokenIn == zkusd) {// sellZKUSD\n            amountOut = IVault(vault).sellZKUSD(_tokenOut, _receiver);\n        } else {// swap\n            amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        }\n\n        require(amountOut >= _minOut, \"OrderBook: insufficient amountOut\");\n        return amountOut;\n    }\n    function _createIncreaseOrder(address _purchaseToken, uint256 _purchaseTokenAmount, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _triggerPrice, bool _triggerAboveThreshold, uint256 _executionFee) private {\n        uint256 _orderIndex = increaseOrdersIndex[msg.sender];\n        IncreaseOrder memory order = IncreaseOrder(\n            msg.sender,\n            _purchaseToken,\n            _purchaseTokenAmount,\n            _collateralToken,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            _executionFee\n        );\n        increaseOrdersIndex[msg.sender] = _orderIndex.add(1);\n        increaseOrders[msg.sender][_orderIndex] = order;\n\n        emit Events.CreateIncreaseOrder(\n            msg.sender,\n            _orderIndex,\n            _purchaseToken,\n            _purchaseTokenAmount,\n            _collateralToken,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            _executionFee\n        );\n    }\n    function _createDecreaseOrder(address _account, address _collateralToken, uint256 _collateralDelta, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _triggerPrice, bool _triggerAboveThreshold) private {\n        uint256 _orderIndex = decreaseOrdersIndex[_account];\n        DecreaseOrder memory order = DecreaseOrder(\n            _account,\n            _collateralToken,\n            _collateralDelta,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            msg.value\n        );\n        decreaseOrdersIndex[_account] = _orderIndex.add(1);\n        decreaseOrders[_account][_orderIndex] = order;\n\n        emit Events.CreateDecreaseOrder(\n            _account,\n            _orderIndex,\n            _collateralToken,\n            _collateralDelta,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            msg.value\n        );\n    }\n}\n"
    },
    "contracts/core/PositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BasePositionManager.sol\";\nimport \"./BasePriceConsumer.sol\";\nimport \"./settings/PositionManagerSettings.sol\";\n\ncontract PositionManager is BasePositionManager, BasePriceConsumer, PositionManagerSettings {\n\n    constructor(\n        address _vault,\n        address _router,\n        address _shortsTracker,\n        address _weth,\n        uint256 _depositFee,\n        address _orderBook\n    ) public BasePositionManager(_vault, _router, _shortsTracker, _weth, _depositFee) BasePriceConsumer(_vault) {\n        orderBook = _orderBook;\n    }\n\n    /**\n        * @param _path path to swap\n        * @param _indexToken index token\n        * @param _amountIn amount of tokens to swap\n        * @param _minOut minimum amount of tokens to receive\n        * @param _sizeDelta size delta\n        * @param _isLong is long if true, short if false\n        * @param _price price of the index token\n        * @param _updateData data to update\n    */\n    function increasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price,\n        bytes[] calldata _updateData\n    ) external payable nonReentrant onlyPartnersOrOpened {\n        require(_path[0] == zusd, \"PositionManager: invalid path\");\n        uint256 _fee = _update(_updateData);\n        _preChargeFee(msg.sender, _path[_path.length - 1], _indexToken, _isLong, _fee);\n\n        require(_path.length == 1 || _path.length == 2, Errors.POSITIONMANAGER_INVALID_PATH_LENGTH);\n\n        if (_amountIn > 0) {\n            if (_path.length == 1) {\n                IRouter(router).pluginTransfer(_path[0], msg.sender, address(this), _amountIn);\n            } else {\n                IRouter(router).pluginTransfer(_path[0], msg.sender, vault, _amountIn);\n                _amountIn = _swap(_path, _minOut, address(this));\n            }\n            uint256 afterFeeAmount = _collectFees(msg.sender, _path, _amountIn, _indexToken, _isLong, _sizeDelta);\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, afterFeeAmount);\n        }\n        _increasePosition(msg.sender, _path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n\n    /**\n        * @param _path path to swap, one of the tokens must be the index token\n        * @param _indexToken index token which is being sold\n        * @param _collateralDelta collateral delta which is being withdrawn\n        * @param _sizeDelta size delta which is being withdrawn\n        * @param _isLong is long if true, short if false\n        * @param _receiver receiver of the tokens\n        * @param _price price of the index token\n        * @param _minOut minimum amount of tokens to receive\n        * @param _withdrawETH withdraw ETH if true, otherwise withdraw ERC20\n        * @param _updateData data to update\n    */\n    function decreasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _price,\n        uint256 _minOut,\n        bool _withdrawETH,\n        bytes[] calldata _updateData\n    ) external payable nonReentrant onlyPartnersOrOpened {\n        require(_path.length == 1 || _path.length == 2, Errors.POSITIONMANAGER_INVALID_PATH_LENGTH);\n        require(!_withdrawETH, \"PositionManager: withdraw ETH not supported for now\");\n        require(_path[_path.length - 1] == zusd, \"PositionManager: invalid path\");\n        _update(_updateData);\n        // if (_withdrawETH) require(_path[_path.length - 1] == weth, Errors.POSITIONMANAGER_INVALID_PATH);\n\n        uint256 amountOut = _decreasePosition(msg.sender, _path[0], _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        _transferOut(amountOut, _path, _receiver, _minOut, _withdrawETH);\n    }\n\n    function _transferOut(\n        uint256 amountOut,\n        address[] memory _path,\n        address _receiver,\n        uint256 _minOut,\n        bool _withdrawETH\n    ) private {\n        if (amountOut > 0) {\n            if (_path.length > 1) {\n                IERC20(_path[0]).safeTransfer(vault, amountOut);\n                amountOut = _swap(_path, _minOut, address(this));\n            }\n            if (_withdrawETH) {\n                _transferOutETH(amountOut, payable(_receiver));\n            } else {\n                IERC20(_path[_path.length - 1]).safeTransfer(_receiver, amountOut);\n            }\n        }\n    }\n\n    /**\n        * @param _account account to liquidate\n        * @param _collateralToken collateral token\n        * @param _indexToken index token\n        * @param _isLong is long if true, short if false\n        * @param _feeReceiver receiver of the fee\n        * @param _updateData data to update\n    */\n    function liquidatePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        address payable _feeReceiver,\n        bytes[] calldata _updateData\n    ) external payable nonReentrant {\n        require(isLiquidator[msg.sender] || msg.sender == _account, Errors.POSITIONMANAGER_FORBIDDEN);\n        _update(_updateData);\n        address _vault = vault;\n        address timelock = IVault(_vault).gov();\n        (uint256 size, , , , , , ,) = IVault(vault).getPosition(_account, _collateralToken, _indexToken, _isLong);\n        uint256 markPrice = _isLong ? IVault(_vault).getMinPrice(_indexToken) : IVault(_vault).getMaxPrice(_indexToken);\n\n        IShortsTracker(shortsTracker).updateGlobalShortData(_account, _collateralToken, _indexToken, _isLong, size, markPrice, false);\n        ITimelock(timelock).enableLeverage(_vault);\n        uint256 _amount = IVault(_vault).liquidatePosition(_account, _collateralToken, _indexToken, _isLong, _feeReceiver);\n        // liq zusd out\n        if (_collateralToken == zusd) {\n            IERC20(_collateralToken).safeTransfer(_account, _amount);\n        } else {\n            IERC20(_collateralToken).safeTransfer(vault, _amount);\n            address[] memory _path = new address[](2);\n            _path[0] = _collateralToken;\n            _path[1] = zusd;\n            _swap(_path, 0, _account);\n        }\n        ITimelock(timelock).disableLeverage(_vault);\n        _payLiquidator(_account, _collateralToken, _indexToken, _isLong, _feeReceiver);\n    }\n\n    /**\n        * @param _account account to liquidate\n        * @param _orderIndex order index which is being liquidated\n        * @param _feeReceiver receiver of the fee\n        * @param _updateData data to update which is being liquidated\n    */\n    function executeIncreaseOrder(\n        address _account,\n        uint256 _orderIndex,\n        address payable _feeReceiver,\n        bytes[] calldata _updateData\n    ) external payable onlyOrderKeeper {\n        _update(_updateData);\n        _validateIncreaseOrder(_account, _orderIndex);\n\n        address _vault = vault;\n        address timelock = IVault(_vault).gov();\n\n        (\n        /*address purchaseToken*/,\n        /*uint256 purchaseTokenAmount*/,\n            address collateralToken,\n            address indexToken,\n            uint256 sizeDelta,\n            bool isLong,\n        /*uint256 triggerPrice*/,\n        /*bool triggerAboveThreshold*/,\n        /*uint256 executionFee*/\n        ) = IOrderBook(orderBook).getIncreaseOrder(_account, _orderIndex);\n\n        uint256 markPrice = isLong ? IVault(_vault).getMaxPrice(indexToken) : IVault(_vault).getMinPrice(indexToken);\n        IShortsTracker(shortsTracker).updateGlobalShortData(_account, collateralToken, indexToken, isLong, sizeDelta, markPrice, true);\n\n        ITimelock(timelock).enableLeverage(_vault);\n        IOrderBook(orderBook).executeIncreaseOrder(_account, _orderIndex, _feeReceiver);\n        ITimelock(timelock).disableLeverage(_vault);\n\n    }\n\n    /**\n        * @param _account account to liquidate\n        * @param _orderIndex order index which is being liquidated\n        * @param _feeReceiver receiver of the fee\n        * @param _updateData data to update which is being liquidated\n    */\n    function executeDecreaseOrder(\n        address _account,\n        uint256 _orderIndex,\n        address payable _feeReceiver,\n        bytes[] calldata _updateData\n    ) external payable onlyOrderKeeper {\n        _update(_updateData);\n        address _vault = vault;\n        address timelock = IVault(_vault).gov();\n\n        (\n            address collateralToken,\n        /*uint256 collateralDelta*/,\n            address indexToken,\n            uint256 sizeDelta,\n            bool isLong,\n        /*uint256 triggerPrice*/,\n        /*bool triggerAboveThreshold*/,\n        /*uint256 executionFee*/\n        ) = IOrderBook(orderBook).getDecreaseOrder(_account, _orderIndex);\n\n        uint256 markPrice = isLong ? IVault(_vault).getMinPrice(indexToken) : IVault(_vault).getMaxPrice(indexToken);\n        IShortsTracker(shortsTracker).updateGlobalShortData(_account, collateralToken, indexToken, isLong, sizeDelta, markPrice, false);\n\n        ITimelock(timelock).enableLeverage(_vault);\n        IOrderBook(orderBook).executeDecreaseOrder(_account, _orderIndex, _feeReceiver);\n        ITimelock(timelock).disableLeverage(_vault);\n\n    }\n\n    function _validateIncreaseOrder(address _account, uint256 _orderIndex) internal view {\n        (\n            address _purchaseToken,\n            uint256 _purchaseTokenAmount,\n            address _collateralToken,\n            address _indexToken,\n            uint256 _sizeDelta,\n            bool _isLong,\n            , // triggerPrice\n            , // triggerAboveThreshold\n        // executionFee\n        ) = IOrderBook(orderBook).getIncreaseOrder(_account, _orderIndex);\n\n        _validateMaxGlobalSize(_indexToken, _isLong, _sizeDelta);\n\n        if (!shouldValidateIncreaseOrder) {return;}\n\n        // shorts are okay\n        if (!_isLong) {return;}\n\n        // if the position size is not increasing, this is a collateral deposit\n        require(_sizeDelta > 0, \"PositionManager: long deposit\");\n\n        IVault _vault = IVault(vault);\n        (uint256 size, uint256 collateral, , , , , ,) = _vault.getPosition(_account, _collateralToken, _indexToken, _isLong);\n\n        // if there is no existing position, do not charge a fee\n        if (size == 0) {return;}\n\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 collateralDelta = _vault.tokenToUsdMin(_purchaseToken, _purchaseTokenAmount);\n        uint256 nextCollateral = collateral.add(collateralDelta);\n\n        uint256 prevLeverage = size.mul(BASIS_POINTS_DIVISOR).div(collateral);\n        // allow for a maximum of a increasePositionBufferBps decrease since there might be some swap fees taken from the collateral\n        uint256 nextLeverageWithBuffer = nextSize.mul(BASIS_POINTS_DIVISOR + increasePositionBufferBps).div(nextCollateral);\n\n        require(nextLeverageWithBuffer >= prevLeverage, \"PositionManager: long leverage decrease\");\n    }\n}\n"
    },
    "contracts/core/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./settings/RouterSettings.sol\";\nimport \"./BasePriceConsumer.sol\";\n\ncontract Router is RouterSettings, BasePriceConsumer {\n    \n    constructor(address _vault, address _zkusd, address _weth) BasePriceConsumer(_vault) public {\n        vault = _vault;\n        zkusd = _zkusd;\n        weth = _weth;\n        gov = msg.sender;\n    }\n\n    receive() external payable {\n        require(msg.sender == weth, Errors.ROUTER_INVALID_SENDER);\n    }\n\n    function addPlugin(address _plugin) external override onlyGov {\n        plugins[_plugin] = true;\n    }\n\n    function removePlugin(address _plugin) external onlyGov {\n        plugins[_plugin] = false;\n    }\n\n    function pluginTransfer(address _token, address _account, address _receiver, uint256 _amount) external override {\n        _validatePlugin();\n        IERC20(_token).safeTransferFrom(_account, _receiver, _amount);\n    }\n\n    function pluginIncreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong\n    ) external override {\n        _validatePlugin();\n        IVault(vault).increasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n    }\n\n    function pluginDecreasePosition(\n        address _account, \n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external override returns (uint256) {\n        _validatePlugin();\n        return IVault(vault).decreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n    }\n\n    function directPoolDeposit(address _token, uint256 _amount) external {\n        IERC20(_token).safeTransferFrom(_sender(), vault, _amount);\n        IVault(vault).directPoolDeposit(_token);\n    }\n\n    function swap(\n        address[] memory _path, \n        uint256 _amountIn, \n        uint256 _minOut,\n        address _receiver,\n        bytes[] calldata _updateData\n    ) public payable {\n        _update(_updateData);\n        IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\n        emit Events.Swap(msg.sender, _path[0], _path[_path.length - 1], _amountIn, amountOut);\n    }\n\n    function swapETHToTokens(\n        address[] memory _path, \n        uint256 _minOut,\n        address _receiver,\n        bytes[] calldata _updateData\n    ) external payable {\n        uint256 _fee = _update(_updateData);\n        require(_path[0] == weth, Errors.ROUTER_INVALID_PATH);\n        \n        uint256 _amountIn = msg.value.sub(_fee);\n        _transferETHToVault(_amountIn);\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\n        emit Events.Swap(msg.sender, _path[0], _path[_path.length - 1], _amountIn, amountOut);\n    }\n\n    function swapTokensToETH(\n        address[] memory _path,\n        uint256 _amountIn,\n        uint256 _minOut,\n        address payable _receiver,\n        bytes[] calldata _updateData\n    ) external payable {\n        _update(_updateData);\n        require(_path[_path.length - 1] == weth, Errors.ROUTER_INVALID_PATH);\n        IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        uint256 amountOut = _swap(_path, _minOut, address(this));\n        _transferOutETH(amountOut, _receiver);\n        emit Events.Swap(msg.sender, _path[0], _path[_path.length - 1], _amountIn, amountOut);\n    }\n}\n"
    },
    "contracts/core/settings/BasePositionManagerAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IShortsTracker.sol\";\nimport \"../interfaces/IOrderBook.sol\";\nimport \"../../peripherals/interfaces/ITimelock.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../../access/Governable.sol\";\nabstract contract BasePositionManagerAggregator is Governable, ReentrancyGuard{\n}"
    },
    "contracts/core/settings/BasePositionManagerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../storage/BasePositionManagerStorage.sol\";\nimport \"./BasePositionManagerAggregator.sol\";\n\nabstract contract BasePositionManagerSettings is BasePositionManagerAggregator, BasePositionManagerStorage {\n    function setAdmin(address _admin) external onlyGov {\n        admin = _admin;\n        emit Events.SetAdmin(_admin);\n    }\n\n    function setDepositFee(uint256 _depositFee) external onlyAdmin {\n        depositFee = _depositFee;\n        emit Events.SetDepositFee(_depositFee);\n    }\n\n    function setIncreasePositionBufferBps(uint256 _increasePositionBufferBps) external onlyAdmin {\n        increasePositionBufferBps = _increasePositionBufferBps;\n        emit Events.SetIncreasePositionBufferBps(_increasePositionBufferBps);\n    }\n\n    function setMaxGlobalSizes(address[] memory _tokens, uint256[] memory _longSizes, uint256[] memory _shortSizes) external onlyAdmin {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            maxGlobalLongSizes[token] = _longSizes[i];\n            maxGlobalShortSizes[token] = _shortSizes[i];\n        }\n        emit Events.SetMaxGlobalSizes(_tokens, _longSizes, _shortSizes);\n    }\n\n    function setMinLiquidationFee(uint256 _minLiquidateFee) external onlyAdmin {\n        minLiquidationFee = _minLiquidateFee;\n    }\n\n    function _validateMaxGlobalSize(address _indexToken, bool _isLong, uint256 _sizeDelta) internal view {\n        if (_sizeDelta == 0) {\n            return;\n        }\n        if (_isLong) {\n            uint256 maxGlobalLongSize = maxGlobalLongSizes[_indexToken];\n            if (maxGlobalLongSize > 0 && IVault(vault).guaranteedUsd(_indexToken).add(_sizeDelta) > maxGlobalLongSize) {\n                revert(Errors.BASEPOSITIONMANAGER_MAX_GLOBAL_LONGS_EXCEEDED);\n            }\n        } else {\n            uint256 maxGlobalShortSize = maxGlobalShortSizes[_indexToken];\n            if (maxGlobalShortSize > 0 && IVault(vault).globalShortSizes(_indexToken).add(_sizeDelta) > maxGlobalShortSize) {\n                revert(Errors.BASEPOSITIONMANAGER_MAX_GLOBAL_SHORTS_EXCEEDED);\n            }\n        }\n    }\n\n    function _increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _price) internal {\n        address _vault = vault;\n        uint256 markPrice = _isLong ? IVault(_vault).getMaxPrice(_indexToken) : IVault(_vault).getMinPrice(_indexToken);\n        if (_isLong) {\n            require(markPrice <= _price, Errors.BASEPOSITIONMANAGER_MARK_PRICE_HIGHER_THAN_LIMIT);\n        } else {\n            require(markPrice >= _price, Errors.BASEPOSITIONMANAGER_MARK_PRICE_LOWER_THAN_LIMIT);\n        }\n        _validateMaxGlobalSize(_indexToken, _isLong, _sizeDelta);\n        address timelock = IVault(_vault).gov();\n        IShortsTracker(shortsTracker).updateGlobalShortData(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, markPrice, true);\n        ITimelock(timelock).enableLeverage(_vault);\n        IRouter(router).pluginIncreasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n        ITimelock(timelock).disableLeverage(_vault);\n    }\n\n    function _decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price) internal returns (uint256) {\n        address _vault = vault;\n        uint256 markPrice = _isLong ? IVault(_vault).getMinPrice(_indexToken) : IVault(_vault).getMaxPrice(_indexToken);\n        if (_isLong) {\n            require(markPrice >= _price, Errors.BASEPOSITIONMANAGER_MARK_PRICE_LOWER_THAN_LIMIT);\n        } else {\n            require(markPrice <= _price, Errors.BASEPOSITIONMANAGER_MARK_PRICE_HIGHER_THAN_LIMIT);\n        }\n        address timelock = IVault(_vault).gov();\n        IShortsTracker(shortsTracker).updateGlobalShortData(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, markPrice, false);\n        ITimelock(timelock).enableLeverage(_vault);\n        uint256 amountOut = IRouter(router).pluginDecreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n        ITimelock(timelock).disableLeverage(_vault);\n        return amountOut;\n    }\n\n    function _swap(address[] memory _path, uint256 _minOut, address _receiver) internal returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        revert(Errors.BASEPOSITIONMANAGER_INVALID_PATH_LENGTH);\n    }\n\n    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) internal returns (uint256) {\n        uint256 amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        require(amountOut >= _minOut, Errors.BASEPOSITIONMANAGER_INSUFFICIENT_AMOUNTOUT);\n        return amountOut;\n    }\n\n    function _transferInETH(uint256 _amount) internal {\n        IWETH(weth).deposit{value : _amount}();\n    }\n\n    function _transferOutETH(uint256 _amountOut, address payable _receiver) internal {\n        IWETH(weth).withdraw(_amountOut);\n        (bool sent,) = _receiver.call{value : _amountOut}(\"\");\n        require(sent, Errors.BASEPOSITIONMANAGER_TRANSFER_OUT_FAILED);\n    }\n\n    function _collectFees(address _account, address[] memory _path, uint256 _amountIn, address _indexToken, bool _isLong, uint256 _sizeDelta) internal returns (uint256) {\n        bool shouldDeductFee = _shouldDeductFee(_account, _path, _amountIn, _indexToken, _isLong, _sizeDelta);\n        if (shouldDeductFee) {\n            uint256 afterFeeAmount = _amountIn.mul(BASIS_POINTS_DIVISOR.sub(depositFee)).div(BASIS_POINTS_DIVISOR);\n            uint256 feeAmount = _amountIn.sub(afterFeeAmount);\n            address feeToken = _path[_path.length - 1];\n            feeReserves[feeToken] = feeReserves[feeToken].add(feeAmount);\n            return afterFeeAmount;\n        }\n        return _amountIn;\n    }\n\n    function _shouldDeductFee(address _account, address[] memory _path, uint256 _amountIn, address _indexToken, bool _isLong, uint256 _sizeDelta) internal view returns (bool) {\n        if (!_isLong) {return false;}\n        if (_sizeDelta == 0) {return true;}\n        address collateralToken = _path[_path.length - 1];\n        IVault _vault = IVault(vault);\n        (uint256 size, uint256 collateral, , , , , ,) = _vault.getPosition(_account, collateralToken, _indexToken, _isLong);\n        if (size == 0) {return false;}\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 collateralDelta = _vault.tokenToUsdMin(collateralToken, _amountIn);\n        uint256 nextCollateral = collateral.add(collateralDelta);\n        uint256 prevLeverage = size.mul(BASIS_POINTS_DIVISOR).div(collateral);\n        uint256 nextLeverage = nextSize.mul(BASIS_POINTS_DIVISOR + increasePositionBufferBps).div(nextCollateral);\n        return nextLeverage < prevLeverage;\n    }\n\n    function setZusd(address _zusd) external onlyAdmin {\n        zusd = _zusd;\n    }\n}\n"
    },
    "contracts/core/settings/OrderBookSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/OrderBookStorage.sol\";\n\nabstract contract OrderBookSettings is OrderBookStorage {\n    function setMinExecutionFee(uint256 _minExecutionFee) external onlyGov {\n        minExecutionFee = _minExecutionFee;\n        emit Events.UpdateMinExecutionFee(_minExecutionFee);\n    }\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n        emit Events.UpdateGov(_gov);\n    }\n    function getIncreaseOrder(address _account, uint256 _orderIndex) override public view returns (\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    ) {\n        IncreaseOrder memory order = increaseOrders[_account][_orderIndex];\n        return (\n        order.purchaseToken,\n        order.purchaseTokenAmount,\n        order.collateralToken,\n        order.indexToken,\n        order.sizeDelta,\n        order.isLong,\n        order.triggerPrice,\n        order.triggerAboveThreshold,\n        order.executionFee\n        );\n    }\n    function getDecreaseOrder(address _account, uint256 _orderIndex) override public view returns (\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    ) {\n        DecreaseOrder memory order = decreaseOrders[_account][_orderIndex];\n        return (\n        order.collateralToken,\n        order.collateralDelta,\n        order.indexToken,\n        order.sizeDelta,\n        order.isLong,\n        order.triggerPrice,\n        order.triggerAboveThreshold,\n        order.executionFee\n        );\n    }\n    function validatePositionOrderPrice(\n        bool _triggerAboveThreshold,\n        uint256 _triggerPrice,\n        address _indexToken,\n        bool _maximizePrice,\n        bool _raise\n    ) public view returns (uint256, bool) {\n        uint256 currentPrice = _maximizePrice\n        ? IVault(vault).getMaxPrice(_indexToken) : IVault(vault).getMinPrice(_indexToken);\n        bool isPriceValid = _triggerAboveThreshold ? currentPrice > _triggerPrice : currentPrice < _triggerPrice;\n        if (_raise) {\n            require(isPriceValid, \"OrderBook: invalid price for execution\");\n        }\n        return (currentPrice, isPriceValid);\n    }\n}"
    },
    "contracts/core/settings/PositionManagerAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IOrderBook.sol\";\nimport \"../../peripherals/interfaces/ITimelock.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nabstract contract PositionManagerAggregator{\n}"
    },
    "contracts/core/settings/PositionManagerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/PositionManagerStorage.sol\";\nimport \"../storage/BasePositionManagerStorage.sol\";\nimport \"./PositionManagerAggregator.sol\";\nabstract contract PositionManagerSettings is PositionManagerStorage, BasePositionManagerStorage, PositionManagerAggregator {\n\n    function setOrderKeeper(address _account, bool _isActive) external onlyAdmin {\n        isOrderKeeper[_account] = _isActive;\n        emit Events.SetOrderKeeper(_account, _isActive);\n    }\n    function setLiquidator(address _account, bool _isActive) external onlyAdmin {\n        isLiquidator[_account] = _isActive;\n        emit Events.SetLiquidator(_account, _isActive);\n    }\n    function setPartner(address _account, bool _isActive) external onlyAdmin {\n        isPartner[_account] = _isActive;\n        emit Events.SetPartner(_account, _isActive);\n    }\n    function setOpened(bool _opened) external onlyAdmin {\n        opened = _opened;\n        emit Events.SetOpened(_opened);\n    }\n    function setShouldValidateIncreaseOrder(bool _shouldValidateIncreaseOrder) external onlyAdmin {\n        shouldValidateIncreaseOrder = _shouldValidateIncreaseOrder;\n        emit Events.SetShouldValidateIncreaseOrder(_shouldValidateIncreaseOrder);\n    }\n    function setOrderBook(address _orderBook) external onlyAdmin {\n        orderBook = _orderBook;\n    }\n}\n"
    },
    "contracts/core/settings/RewardRouterV2Settings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../storage/RewardRouterV2Storage.sol\";\n\nabstract contract RewardRouterV2Settings is RewardRouterV2Storage {\n    \n    function initialize(\n        address _weth,\n        address _zkdx,\n        address _zkdlp,\n        address _zkdlpManager\n    ) external onlyGov {\n        require(!isInitialized, Errors.REWARDROUTER_ALREADY_INITIALIZED);\n        isInitialized = true;\n        weth = _weth;\n        zkdx = _zkdx;\n        zkdlp = _zkdlp;\n        zkdlpManager = _zkdlpManager;\n    }\n}\n"
    },
    "contracts/core/settings/RouterSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../storage/RouterStorage.sol\";\n\nabstract contract RouterSettings is RouterStorage {\n    \n    function _transferETHToVault(uint256 _amount) internal {\n        IWETH(weth).deposit{value : _amount}();\n        IERC20(weth).safeTransfer(vault, _amount);\n    }\n\n    function _transferOutETH(uint256 _amountOut, address payable _receiver) internal {\n        IWETH(weth).withdraw(_amountOut);\n        _receiver.sendValue(_amountOut);\n    }\n\n    function _swap(address[] memory _path, uint256 _minOut, address _receiver) internal returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        if (_path.length == 3) {\n            uint256 midOut = _vaultSwap(_path[0], _path[1], 0, address(this));\n            IERC20(_path[1]).safeTransfer(vault, midOut);\n            return _vaultSwap(_path[1], _path[2], _minOut, _receiver);\n        }\n        revert(Errors.ROUTER_INVALID_PATH_LENGTH);\n    }\n\n    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) internal returns (uint256) {\n        uint256 amountOut;\n        if (_tokenOut == zkusd) {\n            amountOut = IVault(vault).buyZKUSD(_tokenIn, _receiver);\n        } else if (_tokenIn == zkusd) {\n            amountOut = IVault(vault).sellZKUSD(_tokenOut, _receiver);\n        } else {\n            amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        }\n        require(amountOut >= _minOut, Errors.ROUTER_INSUFFICIENT_AMOUNTOUT);\n        return amountOut;\n    }\n\n    function _sender() internal view returns (address) {\n        return msg.sender;\n    }\n\n    function _validatePlugin() internal view {\n        require(plugins[msg.sender], Errors.ROUTER_INVALID_PLUGIN);\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n}\n"
    },
    "contracts/core/settings/ShortsTrackerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/ShortsTrackerStorage.sol\";\nabstract contract ShortsTrackerSettings is ShortsTrackerStorage {\n    /* settings */\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        require(_handler != address(0), Errors.SHORTSTRACKER_INVALID_HANDLER);\n        isHandler[_handler] = _isActive;\n    }\n    function setIsGlobalShortDataReady(bool value) external onlyGov {\n        isGlobalShortDataReady = value;\n    }\n    function setInitData(address[] calldata _tokens, uint256[] calldata _averagePrices) external onlyGov {\n        require(!isGlobalShortDataReady, Errors.SHORTSTRACKER_ALREADY_MIGRATED);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            globalShortAveragePrices[_tokens[i]] = _averagePrices[i];\n        }\n        isGlobalShortDataReady = true;\n    }\n}"
    },
    "contracts/core/settings/VaultInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./VaultSettings.sol\";\n\nabstract contract VaultInternal is VaultSettings {\n\n    function _reduceCollateral(\n        address _account, address _collateralToken,\n        address _indexToken, uint256 _collateralDelta,\n        uint256 _sizeDelta, bool _isLong) internal returns (uint256, uint256) {\n\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position storage position = positions[key];\n        uint256 fee = _collectMarginFees(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, position.size, position.entryFundingRate);\n        bool hasProfit;\n        uint256 adjustedDelta;\n        {\n            (bool _hasProfit, uint256 delta) = getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n            hasProfit = _hasProfit;\n            adjustedDelta = _sizeDelta.mul(delta).div(position.size);\n        }\n        uint256 usdOut;\n        if (hasProfit && adjustedDelta > 0) {\n            usdOut = adjustedDelta;\n            position.realisedPnl = position.realisedPnl + int256(adjustedDelta);\n            if (!_isLong) {\n                uint256 tokenAmount = usdToTokenMin(_collateralToken, adjustedDelta);\n                _decreasePoolAmount(_collateralToken, tokenAmount);\n            }\n        }\n        if (!hasProfit && adjustedDelta > 0) {\n            position.collateral = position.collateral.sub(adjustedDelta);\n            if (!_isLong) {\n                uint256 tokenAmount = usdToTokenMin(_collateralToken, adjustedDelta);\n                _increasePoolAmount(_collateralToken, tokenAmount);\n            }\n            position.realisedPnl = position.realisedPnl - int256(adjustedDelta);\n        }\n        if (_collateralDelta > 0) {\n            usdOut = usdOut.add(_collateralDelta);\n            position.collateral = position.collateral.sub(_collateralDelta);\n        }\n        if (position.size == _sizeDelta) {\n            usdOut = usdOut.add(position.collateral);\n            position.collateral = 0;\n        }\n        uint256 usdOutAfterFee = usdOut;\n        if (usdOut > fee) {\n            usdOutAfterFee = usdOut.sub(fee);\n        } else {\n            position.collateral = position.collateral.sub(fee);\n            if (_isLong) {\n                uint256 feeTokens = usdToTokenMin(_collateralToken, fee);\n                _decreasePoolAmount(_collateralToken, feeTokens);\n            }\n        }\n        emit Events.UpdatePnl(key, hasProfit, adjustedDelta);\n        return (usdOut, usdOutAfterFee);\n    }\n\n    function _collectSwapFees(address _token, uint256 _amount, uint256 _feeBasisPoints) internal returns (uint256) {\n        uint256 afterFeeAmount = _amount.mul(Constants.BASIS_POINTS_DIVISOR.sub(_feeBasisPoints)).div(Constants.BASIS_POINTS_DIVISOR);\n        uint256 feeAmount = _amount.sub(afterFeeAmount);\n        feeReserves[_token] = feeReserves[_token].add(feeAmount);\n        emit Events.CollectSwapFees(_token, tokenToUsdMin(_token, feeAmount), feeAmount);\n        return afterFeeAmount;\n    }\n\n    function _collectMarginFees(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta, uint256 _size, uint256 _entryFundingRate) internal returns (uint256) {\n        uint256 feeUsd = getPositionFee(_account, _collateralToken, _indexToken, _isLong, _sizeDelta);\n        uint256 fundingFee = getFundingFee(_account, _collateralToken, _indexToken, _isLong, _size, _entryFundingRate);\n        feeUsd = feeUsd.add(fundingFee);\n        uint256 feeTokens = usdToTokenMin(_collateralToken, feeUsd);\n        feeReserves[_collateralToken] = feeReserves[_collateralToken].add(feeTokens);\n        emit Events.CollectMarginFees(_collateralToken, feeUsd, feeTokens);\n        return feeUsd;\n    }\n\n    function _transferIn(address _token) internal returns (uint256) {\n        uint256 prevBalance = tokenBalances[_token];\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        tokenBalances[_token] = nextBalance;\n        return nextBalance.sub(prevBalance);\n    }\n\n    function _transferOut(address _token, uint256 _amount, address _receiver) internal {\n        IERC20(_token).safeTransfer(_receiver, _amount);\n        tokenBalances[_token] = IERC20(_token).balanceOf(address(this));\n    }\n\n    function _updateTokenBalance(address _token) internal {\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        tokenBalances[_token] = nextBalance;\n    }\n\n    function _increasePoolAmount(address _token, uint256 _amount) internal {\n        poolAmounts[_token] = poolAmounts[_token].add(_amount);\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        _validate(poolAmounts[_token] <= balance, 49);\n        emit Events.IncreasePoolAmount(_token, _amount);\n    }\n\n    function _decreasePoolAmount(address _token, uint256 _amount) internal {\n        poolAmounts[_token] = poolAmounts[_token].sub(_amount, Errors.VAULT_POOLAMOUNT_EXCEEDED);\n        _validate(reservedAmounts[_token] <= poolAmounts[_token], 50);\n        emit Events.DecreasePoolAmount(_token, _amount);\n    }\n\n    function _increaseReservedAmount(address _token, uint256 _amount) internal {\n        reservedAmounts[_token] = reservedAmounts[_token].add(_amount);\n        _validate(reservedAmounts[_token] <= poolAmounts[_token], 52);\n        emit Events.IncreaseReservedAmount(_token, _amount);\n    }\n\n    function _decreaseReservedAmount(address _token, uint256 _amount) internal {\n        reservedAmounts[_token] = reservedAmounts[_token].sub(_amount, Errors.VAULT_INSUFFICIENT_RESERVE);\n        emit Events.DecreaseReservedAmount(_token, _amount);\n    }\n\n    function _increaseGuaranteedUsd(address _token, uint256 _usdAmount) internal {\n        guaranteedUsd[_token] = guaranteedUsd[_token].add(_usdAmount);\n        emit Events.IncreaseGuaranteedUsd(_token, _usdAmount);\n    }\n\n    function _decreaseGuaranteedUsd(address _token, uint256 _usdAmount) internal {\n        guaranteedUsd[_token] = guaranteedUsd[_token].sub(_usdAmount);\n        emit Events.DecreaseGuaranteedUsd(_token, _usdAmount);\n    }\n\n    function _increaseGlobalShortSize(address _token, uint256 _amount) internal {\n        globalShortSizes[_token] = globalShortSizes[_token].add(_amount);\n        uint256 maxSize = maxGlobalShortSizes[_token];\n        if (maxSize != 0) {\n            require(globalShortSizes[_token] <= maxSize, Errors.VAULT_MAX_SHORTS_EXCEEDED);\n        }\n    }\n\n    function _decreaseGlobalShortSize(address _token, uint256 _amount) internal {\n        uint256 size = globalShortSizes[_token];\n        if (_amount > size) {\n            globalShortSizes[_token] = 0;\n            return;\n        }\n        globalShortSizes[_token] = size.sub(_amount);\n    }\n\n    function _validateManager() internal view {\n        if (inManagerMode) {\n            _validate(isManager[msg.sender], 54);\n        }\n    }\n\n    function _validateGasPrice() internal view {\n        if (maxGasPrice == 0) {return;}\n        _validate(tx.gasprice <= maxGasPrice, 55);\n    }\n\n    function _validatePosition(uint256 _size, uint256 _collateral) internal view {\n        if (_size == 0) {\n            _validate(_collateral == 0, 39);\n            return;\n        }\n        _validate(_size >= _collateral, 40);\n    }\n\n    function _validateRouter(address _account) internal view {\n        if (msg.sender == _account) {return;}\n        if (msg.sender == router) {return;}\n        _validate(approvedRouters[_account][msg.sender], 41);\n    }\n\n    function _validateTokens(address _collateralToken, address _indexToken, bool _isLong) internal view {\n        if (_isLong) {\n            _validate(_collateralToken == _indexToken, 42);\n            _validate(whitelistedTokens[_collateralToken], 43);\n            _validate(!stableTokens[_collateralToken], 44);\n            return;\n        }\n        _validate(whitelistedTokens[_collateralToken], 45);\n        _validate(stableTokens[_collateralToken], 46);\n        _validate(!stableTokens[_indexToken], 47);\n        _validate(shortableTokens[_indexToken], 48);\n    }\n\n    function _validateBufferAmount(address _token) internal view {\n        if (poolAmounts[_token] < bufferAmounts[_token]) {\n            revert(Errors.VAULT_POOLAMOUNT_BUFFER);\n        }\n    }\n\n    function getNextGlobalShortAveragePrice(address _indexToken, uint256 _nextPrice, uint256 _sizeDelta) public view returns (uint256) {\n        uint256 size = globalShortSizes[_indexToken];\n        uint256 averagePrice = globalShortAveragePrices[_indexToken];\n        uint256 priceDelta = averagePrice > _nextPrice ? averagePrice.sub(_nextPrice) : _nextPrice.sub(averagePrice);\n        uint256 delta = size.mul(priceDelta).div(averagePrice);\n        bool hasProfit = averagePrice > _nextPrice;\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 divisor = hasProfit ? nextSize.sub(delta) : nextSize.add(delta);\n        return _nextPrice.mul(nextSize).div(divisor);\n    }\n\n    function getNextAveragePrice(address _indexToken, uint256 _size, uint256 _averagePrice, bool _isLong, uint256 _nextPrice, uint256 _sizeDelta, uint256 _lastIncreasedTime) public view returns (uint256) {\n        (bool hasProfit, uint256 delta) = getDelta(_indexToken, _size, _averagePrice, _isLong, _lastIncreasedTime);\n        uint256 nextSize = _size.add(_sizeDelta);\n        uint256 divisor;\n        if (_isLong) {\n            divisor = hasProfit ? nextSize.add(delta) : nextSize.sub(delta);\n        } else {\n            divisor = hasProfit ? nextSize.sub(delta) : nextSize.add(delta);\n        }\n        return _nextPrice.mul(nextSize).div(divisor);\n    }\n\n    function getNextFundingRate(address _token) public override view returns (uint256) {\n        if (lastFundingTimes[_token].add(fundingInterval) > block.timestamp) {return 0;}\n        uint256 intervals = block.timestamp.sub(lastFundingTimes[_token]).div(fundingInterval);\n        uint256 poolAmount = poolAmounts[_token];\n        if (poolAmount == 0) {return 0;}\n        uint256 _fundingRateFactor = stableTokens[_token] ? stableFundingRateFactor : fundingRateFactor;\n        return _fundingRateFactor.mul(reservedAmounts[_token]).mul(intervals).div(poolAmount);\n    }\n\n    function getEntryFundingRate(address _collateralToken, address _indexToken, bool _isLong) public view returns (uint256) {\n        return vaultUtils.getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n    }\n\n    function getTargetZkusdAmount(address _token) public override view returns (uint256) {\n        uint256 supply = IERC20(zkusd).totalSupply();\n        if (supply == 0) {return 0;}\n        uint256 weight = tokenWeights[_token];\n        return weight.mul(supply).div(totalTokenWeights);\n    }\n\n    function getRedemptionAmount(address _token, uint256 _zkusdAmount) public override view returns (uint256) {\n        uint256 price = getMaxPrice(_token);\n        uint256 redemptionAmount = _zkusdAmount.mul(Constants.PRICE_PRECISION).div(price);\n        return adjustForDecimals(redemptionAmount, zkusd, _token);\n    }\n\n    function getFeeBasisPoints(address _token, uint256 _zkusdDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) public override view returns (uint256) {\n        return vaultUtils.getFeeBasisPoints(_token, _zkusdDelta, _feeBasisPoints, _taxBasisPoints, _increment);\n    }\n\n    function getPositionKey(address _account, address _collateralToken, address _indexToken, bool _isLong) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_account, _collateralToken, _indexToken, _isLong));\n    }\n\n    function getPosition(address _account, address _collateralToken, address _indexToken, bool _isLong) public override view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position memory position = positions[key];\n        uint256 realisedPnl = position.realisedPnl > 0 ? uint256(position.realisedPnl) : uint256(- position.realisedPnl);\n        return (position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, realisedPnl, position.realisedPnl >= 0, position.lastIncreasedTime);\n    }\n\n    function getPositionDelta(address _account, address _collateralToken, address _indexToken, bool _isLong) public view returns (bool, uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position memory position = positions[key];\n        return getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n    }\n\n    function isPositionExist(address _account, address _collateralToken, address _indexToken, bool _isLong) public override view returns (bool exist, bytes32 key) {\n        key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        exist = positions[key].size > 0;\n    }\n\n    function getFundingFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _size, uint256 _entryFundingRate) public view returns (uint256) {\n        return vaultUtils.getFundingFee(_account, _collateralToken, _indexToken, _isLong, _size, _entryFundingRate);\n    }\n\n    function getMaxPrice(address _token) public override view returns (uint256) {\n        if (equityTokens[_token] && allowStaleEquityPrice)\n            return IVaultPriceFeed(priceFeed).getPrice(_token, true, true, false);\n        return IVaultPriceFeed(priceFeed).getPrice(_token, true, true, true);\n    }\n\n    function getMinPrice(address _token) public override view returns (uint256) {\n        if (equityTokens[_token] && allowStaleEquityPrice)\n            return IVaultPriceFeed(priceFeed).getPrice(_token, true, false, false);\n        return IVaultPriceFeed(priceFeed).getPrice(_token, true, false, true);\n    }\n\n    function getDelta(address _indexToken, uint256 _size, uint256 _averagePrice, bool _isLong, uint256 _lastIncreasedTime) public override view returns (bool, uint256) {\n        _validate(_averagePrice > 0, 38);\n        uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n        uint256 priceDelta = _averagePrice > price ? _averagePrice.sub(price) : price.sub(_averagePrice);\n        uint256 delta = _size.mul(priceDelta).div(_averagePrice);\n        bool hasProfit;\n        if (_isLong) {\n            hasProfit = price > _averagePrice;\n        } else {\n            hasProfit = _averagePrice > price;\n        }\n        uint256 minBps = block.timestamp > _lastIncreasedTime.add(minProfitTime) ? 0 : minProfitBasisPoints[_indexToken];\n        if (hasProfit && delta.mul(Constants.BASIS_POINTS_DIVISOR) <= _size.mul(minBps)) {\n            delta = 0;\n        }\n        return (hasProfit, delta);\n    }\n\n    function usdToTokenMax(address _token, uint256 _usdAmount) public view returns (uint256) {\n        if (_usdAmount == 0) {return 0;}\n        return usdToToken(_token, _usdAmount, getMinPrice(_token));\n    }\n\n    function usdToTokenMin(address _token, uint256 _usdAmount) public view returns (uint256) {\n        if (_usdAmount == 0) {return 0;}\n        return usdToToken(_token, _usdAmount, getMaxPrice(_token));\n    }\n\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) public override view returns (uint256) {\n        if (_tokenAmount == 0) {return 0;}\n        uint256 price = getMinPrice(_token);\n        uint256 decimals = tokenDecimals[_token];\n        return _tokenAmount.mul(price).div(10 ** decimals);\n    }\n\n    function usdToToken(address _token, uint256 _usdAmount, uint256 _price) public view returns (uint256) {\n        if (_usdAmount == 0) {return 0;}\n        uint256 decimals = tokenDecimals[_token];\n        return _usdAmount.mul(10 ** decimals).div(_price);\n    }\n\n    function adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) public view returns (uint256) {\n        uint256 decimalsDiv = _tokenDiv == zkusd ? Constants.ZKUSD_DECIMALS : tokenDecimals[_tokenDiv];\n        uint256 decimalsMul = _tokenMul == zkusd ? Constants.ZKUSD_DECIMALS : tokenDecimals[_tokenMul];\n        return _amount.mul(10 ** decimalsMul).div(10 ** decimalsDiv);\n    }\n\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) override public view returns (uint256, uint256) {\n        return vaultUtils.validateLiquidation(_account, _collateralToken, _indexToken, _isLong, _raise);\n    }\n\n    function getPositionFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta) public view returns (uint256) {\n        return vaultUtils.getPositionFee(_account, _collateralToken, _indexToken, _isLong, _sizeDelta);\n    }\n\n    function allWhitelistedTokensLength() external override view returns (uint256) {\n        return allWhitelistedTokens.length;\n    }\n    /* funcs */\n    function addRouter(address _router) external {\n        approvedRouters[msg.sender][_router] = true;\n    }\n\n    function removeRouter(address _router) external {\n        approvedRouters[msg.sender][_router] = false;\n    }\n\n    function upgradeVault(address _newVault, address _token, uint256 _amount) external {\n        _onlyGov();\n        IERC20(_token).safeTransfer(_newVault, _amount);\n    }\n}\n"
    },
    "contracts/core/settings/VaultSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../storage/VaultStorage.sol\";\n\nabstract contract VaultSettings is VaultStorage {\n\n    function _onlyGov() internal view {\n        _validate(msg.sender == gov, 53);\n    }\n\n    function setVaultUtils(IVaultUtils _vaultUtils) external override {\n        _onlyGov();\n        vaultUtils = _vaultUtils;\n    }\n\n    function setErrorController(address _errorController) external {\n        _onlyGov();\n        errorController = _errorController;\n    }\n\n    function setError(uint256 _errorCode, string calldata _error) external override {\n        require(msg.sender == errorController, Errors.VAULT_INVALID_ERRORCONTROLLER);\n        errors[_errorCode] = _error;\n    }\n\n    function setInManagerMode(bool _inManagerMode) external override {\n        _onlyGov();\n        inManagerMode = _inManagerMode;\n    }\n\n    function setManager(address _manager, bool _isManager) external override {\n        _onlyGov();\n        isManager[_manager] = _isManager;\n    }\n\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external override {\n        _onlyGov();\n        inPrivateLiquidationMode = _inPrivateLiquidationMode;\n    }\n\n    function setLiquidator(address _liquidator, bool _isActive) external override {\n        _onlyGov();\n        isLiquidator[_liquidator] = _isActive;\n    }\n\n    function setIsSwapEnabled(bool _isSwapEnabled) external override {\n        _onlyGov();\n        isSwapEnabled = _isSwapEnabled;\n    }\n\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external override {\n        _onlyGov();\n        isLeverageEnabled = _isLeverageEnabled;\n    }\n\n    function setMaxGasPrice(uint256 _maxGasPrice) external override {\n        _onlyGov();\n        maxGasPrice = _maxGasPrice;\n    }\n\n    function setGov(address _gov) external {\n        _onlyGov();\n        gov = _gov;\n    }\n\n    function setPriceFeed(address _priceFeed) external override {\n        _onlyGov();\n        priceFeed = _priceFeed;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override {\n        _onlyGov();\n        _validate(_maxLeverage > Constants.MIN_LEVERAGE, 2);\n        maxLeverage = _maxLeverage;\n    }\n\n    function setBufferAmount(address _token, uint256 _amount) external override {\n        _onlyGov();\n        bufferAmounts[_token] = _amount;\n    }\n\n    function setMaxGlobalShortSize(address _token, uint256 _amount) external override {\n        _onlyGov();\n        maxGlobalShortSizes[_token] = _amount;\n    }\n\n    function setFees(\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd,\n        uint256 _minProfitTime,\n        bool _hasDynamicFees\n    ) external override {\n\n        _onlyGov();\n        _validate(_taxBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 3);\n        _validate(_stableTaxBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 4);\n        _validate(_mintBurnFeeBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 5);\n        _validate(_swapFeeBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 6);\n        _validate(_stableSwapFeeBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 7);\n        _validate(_marginFeeBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 8);\n        _validate(_liquidationFeeUsd <= Constants.MAX_LIQUIDATION_FEE_USD, 9);\n        taxBasisPoints = _taxBasisPoints;\n        stableTaxBasisPoints = _stableTaxBasisPoints;\n        mintBurnFeeBasisPoints = _mintBurnFeeBasisPoints;\n        swapFeeBasisPoints = _swapFeeBasisPoints;\n        stableSwapFeeBasisPoints = _stableSwapFeeBasisPoints;\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        liquidationFeeUsd = _liquidationFeeUsd;\n        minProfitTime = _minProfitTime;\n        hasDynamicFees = _hasDynamicFees;\n    }\n\n    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external override {\n        _onlyGov();\n        fundingInterval = _fundingInterval;\n        fundingRateFactor = _fundingRateFactor;\n        stableFundingRateFactor = _stableFundingRateFactor;\n    }\n\n    function setTokenConfig(\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxZkusdAmount,\n        bool _isStable,\n        bool _isShortable,\n        bool _isEquity\n    ) external override {\n        _onlyGov();\n        if (!whitelistedTokens[_token]) {\n            whitelistedTokenCount = whitelistedTokenCount.add(1);\n            allWhitelistedTokens.push(_token);\n        }\n        uint256 _totalTokenWeights = totalTokenWeights;\n        _totalTokenWeights = _totalTokenWeights.sub(tokenWeights[_token]);\n\n        whitelistedTokens[_token] = true;\n        tokenDecimals[_token] = _tokenDecimals;\n        tokenWeights[_token] = _tokenWeight;\n        minProfitBasisPoints[_token] = _minProfitBps;\n        maxZkusdAmounts[_token] = _maxZkusdAmount;\n        stableTokens[_token] = _isStable;\n        shortableTokens[_token] = _isShortable;\n        equityTokens[_token] = _isEquity;\n        totalTokenWeights = _totalTokenWeights.add(_tokenWeight);\n    }\n\n    function setMinProfitTime(uint256 _minProfitTime) external override {\n        _onlyGov();\n        minProfitTime = _minProfitTime;\n    }\n\n    function setZkusdAmount(address _token, uint256 _amount) external override {\n        _onlyGov();\n        uint256 zkusdAmount = zkusdAmounts[_token];\n        if (_amount > zkusdAmount) {\n            _increaseZkusdAmount(_token, _amount.sub(zkusdAmount));\n            return;\n        }\n        _decreaseZkusdAmount(_token, zkusdAmount.sub(_amount));\n    }\n\n    function setAllowStableEquity(bool _allowStaleEquityPrice) external override {\n        _onlyGov();\n        allowStaleEquityPrice = _allowStaleEquityPrice;\n    }\n\n    function setZusd(address _zusd) external override {\n        _onlyGov();\n        zusd = _zusd;\n    }\n\n    function _validate(bool _condition, uint256 _errorCode) internal view {\n        require(_condition, errors[_errorCode]);\n    }\n\n    function _increaseZkusdAmount(address _token, uint256 _amount) internal {\n        zkusdAmounts[_token] = zkusdAmounts[_token].add(_amount);\n        uint256 maxZkusdAmount = maxZkusdAmounts[_token];\n        if (maxZkusdAmount != 0) {\n            _validate(zkusdAmounts[_token] <= maxZkusdAmount, 51);\n        }\n        emit Events.IncreaseZkusdAmount(_token, _amount);\n    }\n\n    function _decreaseZkusdAmount(address _token, uint256 _amount) internal {\n        uint256 value = zkusdAmounts[_token];\n        if (value <= _amount) {\n            zkusdAmounts[_token] = 0;\n            emit Events.DecreaseZkusdAmount(_token, value);\n            return;\n        }\n        zkusdAmounts[_token] = value.sub(_amount);\n        emit Events.DecreaseZkusdAmount(_token, _amount);\n    }\n}\n"
    },
    "contracts/core/settings/ZkdlpManagerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/ZkdlpManagerStorage.sol\";\nabstract contract ZkdlpManagerSettings is ZkdlpManagerStorage {\n    function setInPrivateMode(bool _inPrivateMode) external onlyGov {\n        inPrivateMode = _inPrivateMode;\n    }\n    function setShortsTrackerAveragePriceWeight(uint256 _shortsTrackerAveragePriceWeight) external onlyGov {\n        require(_shortsTrackerAveragePriceWeight <= Constants.BASIS_POINTS_DIVISOR, Errors.ZKDLPMANAGER_INVALID_WEIGHT);\n        shortsTrackerAveragePriceWeight = _shortsTrackerAveragePriceWeight;\n    }\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n    function setCooldownDuration(uint256 _cooldownDuration) external onlyGov {\n        require(_cooldownDuration <= Constants.MAX_COOLDOWN_DURATION, Errors.ZKDLPMANAGER_INVALID_COOLDOWNDURATION);\n        cooldownDuration = _cooldownDuration;\n    }\n    function setAumAdjustment(uint256 _aumAddition, uint256 _aumDeduction) external onlyGov {\n        aumAddition = _aumAddition;\n        aumDeduction = _aumDeduction;\n    }\n}\n"
    },
    "contracts/core/ShortsTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./settings/ShortsTrackerSettings.sol\";\n\ncontract ShortsTracker is ShortsTrackerSettings {\n    \n    constructor(address _vault) public {\n        vault = IVault(_vault);\n    }\n    function updateGlobalShortData(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta, uint256 _markPrice, bool _isIncrease) override external onlyHandler {\n        if (_isLong || _sizeDelta == 0) {\n            return;\n        }\n        if (!isGlobalShortDataReady) {\n            return;\n        }\n        (uint256 globalShortSize, uint256 globalShortAveragePrice) = getNextGlobalShortData(_account, _collateralToken, _indexToken, _markPrice, _sizeDelta, _isIncrease);\n        _setGlobalShortAveragePrice(_indexToken, globalShortAveragePrice);\n        emit Events.GlobalShortDataUpdated(_indexToken, globalShortSize, globalShortAveragePrice);\n    }\n\n    function _setGlobalShortAveragePrice(address _token, uint256 _averagePrice) internal {\n        globalShortAveragePrices[_token] = _averagePrice;\n    }\n    \n    function getNextGlobalShortData(address _account, address _collateralToken, address _indexToken, uint256 _nextPrice, uint256 _sizeDelta, bool _isIncrease) override public view returns (uint256, uint256) {\n        int256 realisedPnl = getRealisedPnl(_account, _collateralToken, _indexToken, _sizeDelta, _isIncrease);\n        uint256 averagePrice = globalShortAveragePrices[_indexToken];\n        uint256 priceDelta = averagePrice > _nextPrice ? averagePrice.sub(_nextPrice) : _nextPrice.sub(averagePrice);\n        uint256 nextSize;\n        uint256 delta;\n        {\n            uint256 size = vault.globalShortSizes(_indexToken);\n            nextSize = _isIncrease ? size.add(_sizeDelta) : size.sub(_sizeDelta);\n            if (nextSize == 0) {\n                return (0, 0);\n            }\n            if (averagePrice == 0) {\n                return (nextSize, _nextPrice);\n            }\n            delta = size.mul(priceDelta).div(averagePrice);\n        }\n        uint256 nextAveragePrice = _getNextGlobalAveragePrice(averagePrice, _nextPrice, nextSize, delta, realisedPnl);\n        return (nextSize, nextAveragePrice);\n    }\n\n    function getRealisedPnl(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isIncrease) public view returns (int256) {\n        if (_isIncrease) {\n            return 0;\n        }\n        IVault _vault = vault;\n        (uint256 size, , uint256 averagePrice, , , , , uint256 lastIncreasedTime) = _vault.getPosition(_account, _collateralToken, _indexToken, false);\n        (bool hasProfit, uint256 delta) = _vault.getDelta(_indexToken, size, averagePrice, false, lastIncreasedTime);\n        uint256 adjustedDelta = _sizeDelta.mul(delta).div(size);\n        require(adjustedDelta < Constants.MAX_INT256, Errors.SHORTSTRACKER_OVERFLOW);\n        return hasProfit ? int256(adjustedDelta) : - int256(adjustedDelta);\n    }\n\n    function _getNextGlobalAveragePrice(uint256 _averagePrice, uint256 _nextPrice, uint256 _nextSize, uint256 _delta, int256 _realisedPnl) internal pure returns (uint256) {\n        (bool hasProfit, uint256 nextDelta) = _getNextDelta(_delta, _averagePrice, _nextPrice, _realisedPnl);\n        uint256 nextAveragePrice = _nextPrice\n        .mul(_nextSize)\n        .div(hasProfit ? _nextSize.sub(nextDelta) : _nextSize.add(nextDelta));\n        return nextAveragePrice;\n    }\n\n    function _getNextDelta(uint256 _delta, uint256 _averagePrice, uint256 _nextPrice, int256 _realisedPnl) internal pure returns (bool, uint256) {\n        bool hasProfit = _averagePrice > _nextPrice;\n        if (hasProfit) {\n            if (_realisedPnl > 0) {\n                if (uint256(_realisedPnl) > _delta) {\n                    _delta = uint256(_realisedPnl).sub(_delta);\n                    hasProfit = false;\n                } else {\n                    _delta = _delta.sub(uint256(_realisedPnl));\n                }\n            } else {\n                _delta = _delta.add(uint256(- _realisedPnl));\n            }\n            return (hasProfit, _delta);\n        }\n        if (_realisedPnl > 0) {\n            _delta = _delta.add(uint256(_realisedPnl));\n        } else {\n            if (uint256(- _realisedPnl) > _delta) {\n                _delta = uint256(- _realisedPnl).sub(_delta);\n                hasProfit = true;\n            } else {\n                _delta = _delta.sub(uint256(- _realisedPnl));\n            }\n        }\n        return (hasProfit, _delta);\n    }\n}\n"
    },
    "contracts/core/storage/BasePositionManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/utils/Address.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../interfaces/IBasePositionManager.sol\";\nabstract contract BasePositionManagerStorage is IBasePositionManager {\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public depositFee;\n    uint256 public increasePositionBufferBps = 100;\n    address public admin;\n    address public vault;\n    address public shortsTracker;\n    address public router;\n    address public weth;\n    mapping(address => uint256) public override maxGlobalLongSizes;\n    mapping(address => uint256) public override maxGlobalShortSizes;\n    mapping(address => uint256) public feeReserves;\n    uint256 public minLiquidationFee;\n    mapping(bytes32 => uint256) public liquidationFees;\n    address public zusd;\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"BasePositionManager: forbidden\");\n        _;\n    }\n    receive() external payable {\n        require(msg.sender == weth, Errors.BASEPOSITIONMANAGER_INVALID_SENDER);\n    }\n}\n"
    },
    "contracts/core/storage/OrderBookAggregators.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/utils/Address.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../../libraries/DataTypes.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IOrderBook.sol\";\nabstract contract OrderBookAggregators is ReentrancyGuard, IOrderBook {\n}"
    },
    "contracts/core/storage/OrderBookStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./OrderBookAggregators.sol\";\n\nabstract contract OrderBookStorage is OrderBookAggregators {\n\n    /* constructor */\n    address public router;\n    address public vault;\n    address public weth;\n    address public zkusd;\n\n    /* settings */\n    uint256 public minExecutionFee;\n    address public gov;\n\n    struct IncreaseOrder {\n        address account;\n        address purchaseToken;\n        uint256 purchaseTokenAmount;\n        address collateralToken;\n        address indexToken;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 triggerPrice;\n        bool triggerAboveThreshold;\n        uint256 executionFee;\n    }\n\n    struct DecreaseOrder {\n        address account;\n        address collateralToken;\n        uint256 collateralDelta;\n        address indexToken;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 triggerPrice;\n        bool triggerAboveThreshold;\n        uint256 executionFee;\n    }\n\n    mapping (address => mapping(uint256 => IncreaseOrder)) public increaseOrders; // account => index => order\n    mapping (address => uint256) public increaseOrdersIndex; // account => index\n    mapping (address => mapping(uint256 => DecreaseOrder)) public decreaseOrders;\n    mapping (address => uint256) public decreaseOrdersIndex;\n\n     /* misc */\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n    modifier onlyGov() {\n        require(msg.sender == gov, Errors.ORDERBOOK_FORBIDDEN);\n        _;\n    }\n}\n"
    },
    "contracts/core/storage/PositionManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/Errors.sol\";\nabstract contract PositionManagerStorage {\n    bool public opened = true;\n    bool public shouldValidateIncreaseOrder = true;\n    address public orderBook;\n    mapping (address => bool) public isOrderKeeper;\n    mapping (address => bool) public isPartner;\n    mapping (address => bool) public isLiquidator;\n    modifier onlyOrderKeeper() {\n        require(isOrderKeeper[msg.sender], Errors.POSITIONMANAGER_FORBIDDEN);\n        _;\n    }\n    modifier onlyPartnersOrOpened() {\n        require(isPartner[msg.sender] || opened, Errors.POSITIONMANAGER_FORBIDDEN);\n        _;\n    }\n}\n"
    },
    "contracts/core/storage/ReaderStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../core/interfaces/IVault.sol\";\nimport \"../../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../../tokens/interfaces/IYieldTracker.sol\";\nimport \"../../tokens/interfaces/IYieldToken.sol\";\n//import \"../../staking/interfaces/IVester.sol\";\nabstract contract ReaderStorage {\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant POSITION_PROPS_LENGTH = 9;\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant ZKUSD_DECIMALS = 18;\n    bool public hasMaxGlobalShortSizes;\n    using SafeMath for uint256;\n}\n"
    },
    "contracts/core/storage/RewardRouterV2Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../../libraries/utils/Address.sol\";\n//import \"../../staking/interfaces/IRewardTracker.sol\";\n//import \"../../staking/interfaces/IVester.sol\";\nimport \"../../tokens/interfaces/IMintable.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../interfaces/IZkdlpManager.sol\";\nimport \"../../access/Governable.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nabstract contract RewardRouterV2Aggregator is ReentrancyGuard, Governable {\n}\n"
    },
    "contracts/core/storage/RewardRouterV2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./RewardRouterV2Aggregator.sol\";\n\nabstract contract RewardRouterV2Storage is RewardRouterV2Aggregator {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n    bool public isInitialized;\n    address public weth;\n    address public zkdx;\n    address public zkdlp;\n    address public zkdlpManager;\n//    mapping(address => address) public pendingReceivers;\n}\n"
    },
    "contracts/core/storage/RouterStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/utils/Address.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IRouter.sol\";\n\nabstract contract RouterStorage is IRouter {\n    address public gov;\n    address public weth;\n    address public zkusd;\n    address public vault;\n    mapping(address => bool) public plugins;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n    modifier onlyGov() {\n        require(msg.sender == gov, Errors.ROUTER_FORBIDDEN);\n        _;\n    }\n}\n"
    },
    "contracts/core/storage/ShortsTrackerAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IShortsTracker.sol\";\nimport \"../../access/Governable.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Constants.sol\";\nabstract contract ShortsTrackerAggregator is IShortsTracker, Governable {\n}"
    },
    "contracts/core/storage/ShortsTrackerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./ShortsTrackerAggregator.sol\";\nabstract contract ShortsTrackerStorage is ShortsTrackerAggregator {\n    /* constructor */\n    IVault public vault;\n    /* Settings */\n    mapping (address => bool) public isHandler;\n    mapping (address => uint256) public override globalShortAveragePrices;\n    bool public override isGlobalShortDataReady;\n    /* misc */\n    mapping (bytes32 => bytes32) public data;\n    using SafeMath for uint256;\n    modifier onlyHandler() {\n        require(isHandler[msg.sender], Errors.SHORTSTRACKER_FORBIDDEN);\n        _;\n    }\n}"
    },
    "contracts/core/storage/TimelockStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\nimport \"../../peripherals/interfaces/ITimelockTarget.sol\";\nimport \"../../peripherals/interfaces/ITimelock.sol\";\nimport \"../../peripherals/interfaces/IHandlerTarget.sol\";\nimport \"../../access/interfaces/IAdmin.sol\";\nimport \"../../core/interfaces/IVault.sol\";\nimport \"../../core/interfaces/IVaultUtils.sol\";\nimport \"../../core/interfaces/IZkdlpManager.sol\";\nimport \"../../tokens/interfaces/IYieldToken.sol\";\nimport \"../../tokens/interfaces/IBaseToken.sol\";\nimport \"../../tokens/interfaces/IMintable.sol\";\nimport \"../../tokens/interfaces/IZKUSD.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\n\nabstract contract TimelockStorage is ITimelock {\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant MAX_BUFFER = 5 days;\n    uint256 public constant MAX_FUNDING_RATE_FACTOR = 10000; // 1%\n    uint256 public buffer;\n    uint256 public maxTokenSupply;\n    uint256 public marginFeeBasisPoints;\n    uint256 public maxMarginFeeBasisPoints;\n    bool public shouldToggleIsLeverageEnabled;\n    address public admin;\n    address public tokenManager;\n    address public mintReceiver;\n    address public zkdlpManager;\n    mapping(bytes32 => uint256) public pendingActions;\n    mapping(address => bool) public isHandler;\n    mapping(address => bool) public isKeeper;\n    using SafeMath for uint256;\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Timelock: forbidden\");\n        _;\n    }\n    modifier onlyHandlerAndAbove() {\n        require(msg.sender == admin || isHandler[msg.sender], \"Timelock: forbidden\");\n        _;\n    }\n    modifier onlyKeeperAndAbove() {\n        require(msg.sender == admin || isHandler[msg.sender] || isKeeper[msg.sender], \"Timelock: forbidden\");\n        _;\n    }\n    modifier onlyTokenManager() {\n        require(msg.sender == tokenManager, \"Timelock: forbidden\");\n        _;\n    }\n}\n"
    },
    "contracts/core/storage/VaultAggregators.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/DataTypes.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/IVaultUtils.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IVaultPriceFeed.sol\";\nimport \"../../tokens/interfaces/IZKUSD.sol\";\n\nabstract contract VaultAggregators is IVault, ReentrancyGuard {\n\n}\n"
    },
    "contracts/core/storage/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./VaultAggregators.sol\";\n\nabstract contract VaultStorage is VaultAggregators {\n    /* constructor */\n    address public override gov;\n    bool public override isInitialized;\n    address public override router;\n    address public override zkusd;\n    address public override priceFeed;\n    uint256 public override liquidationFeeUsd;\n    uint256 public override fundingRateFactor;\n    uint256 public override stableFundingRateFactor;\n    /* Logic */\n    mapping(bytes32 => DataTypes.Position) public positions;\n    mapping(address => uint256) public override poolAmounts;\n    mapping(address => uint256) public override reservedAmounts;\n    uint256 public override maxLeverage = 100 * 10000; // 50x\n    uint256 public override taxBasisPoints = 50; // 0.5%\n    uint256 public override stableTaxBasisPoints = 20; // 0.2%\n    uint256 public override mintBurnFeeBasisPoints = 30; // 0.3%\n    uint256 public override swapFeeBasisPoints = 30; // 0.3%\n    uint256 public override stableSwapFeeBasisPoints = 4; // 0.04%\n    uint256 public override marginFeeBasisPoints = 10; // 0.1%\n    uint256 public override fundingInterval = 1 hours;\n    uint256 public override whitelistedTokenCount;\n    uint256 public override maxGasPrice;\n    uint256 public override minProfitTime;\n    bool public override isSwapEnabled = true;\n    bool public override isLeverageEnabled = true;\n    bool public override hasDynamicFees = false;\n    bool public override inManagerMode = false;\n    bool public override inPrivateLiquidationMode = true;\n    IVaultUtils public vaultUtils;\n    address public errorController;\n    mapping(address => mapping(address => bool)) public override approvedRouters;\n    mapping(address => bool) public override isLiquidator;\n    mapping(address => bool) public override isManager;\n    mapping(address => uint256) public override minProfitBasisPoints;\n    mapping(address => bool) public override stableTokens;\n    mapping(address => bool) public override shortableTokens;\n    mapping(address => bool) public override equityTokens;\n    mapping(address => uint256) public override bufferAmounts;\n    mapping(address => uint256) public override guaranteedUsd;\n    mapping(address => uint256) public override cumulativeFundingRates;\n    mapping(address => uint256) public override lastFundingTimes;\n    mapping(address => uint256) public override feeReserves;\n    mapping(address => uint256) public override globalShortSizes;\n    mapping(address => uint256) public override globalShortAveragePrices;\n    mapping(address => uint256) public override maxGlobalShortSizes;\n    mapping(uint256 => string) public errors;\n    /* Token Settings*/\n    mapping(address => uint256) public override tokenDecimals;\n    mapping(address => uint256) public override tokenBalances;\n    mapping(address => uint256) public override tokenWeights;\n    uint256 public override totalTokenWeights;\n    /* others */\n    address[] public override allWhitelistedTokens;\n    mapping(address => bool) public override whitelistedTokens;\n    mapping(address => uint256) public override zkusdAmounts;\n    mapping(address => uint256) public override maxZkusdAmounts;\n    bool public allowStaleEquityPrice;\n    address public zusd;\n    /* misc */\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n}\n"
    },
    "contracts/core/storage/VaultUtilsStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/DataTypes.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../interfaces/IShortsTracker.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IVaultUtils.sol\";\nimport \"../../access/Governable.sol\";\nabstract contract VaultUtilsStorage  is IVaultUtils,Governable{\n    IVault public vault;\n    using SafeMath for uint256;\n}"
    },
    "contracts/core/storage/YieldTokenStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../tokens/interfaces/IYieldTracker.sol\";\nimport \"../../tokens/interfaces/IYieldToken.sol\";\nabstract contract YieldTokenStorage is IERC20, IYieldToken {\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 public nonStakingSupply;\n    bool public inWhitelistMode;\n    address public gov;\n    address[] public yieldTrackers;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n    mapping (address => bool) public nonStakingAccounts;\n    mapping (address => bool) public admins;\n    mapping (address => bool) public whitelistedHandlers;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    modifier onlyGov() {\n        require(msg.sender == gov, \"YieldToken: forbidden\");\n        _;\n    }\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"YieldToken: forbidden\");\n        _;\n    }\n}"
    },
    "contracts/core/storage/ZkdlpManagerAggregators.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IShortsTracker.sol\";\nimport \"../interfaces/IZkdlpManager.sol\";\nimport \"../interfaces/IVaultPriceFeed.sol\";\nimport \"../../tokens/interfaces/IZKUSD.sol\";\nimport \"../../tokens/interfaces/IMintable.sol\";\nimport \"../../access/Governable.sol\";\n\nabstract contract ZKdlpManagerAggregators is IZkdlpManager, ReentrancyGuard, Governable {\n}\n"
    },
    "contracts/core/storage/ZkdlpManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./ZkdlpManagerAggregators.sol\";\nabstract contract ZkdlpManagerStorage is ZKdlpManagerAggregators {\n    /* constructor */\n    IVault public vault;\n    address public override zkUsd;\n    address public zkdlp;\n    IShortsTracker public shortsTracker;\n    /* settings */\n    bool public inPrivateMode = true;\n    uint256 public shortsTrackerAveragePriceWeight;\n    mapping (address => bool) public isHandler;\n    uint256 public override cooldownDuration;\n    uint256 public aumAddition;\n    uint256 public aumDeduction;\n    /* misc */\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    mapping (address => uint256) public override lastAddedAt;\n}\n"
    },
    "contracts/core/v2/AIPC.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"../../access/Governable.sol\";\npragma solidity ^0.6.0;\ncontract AIPC is Governable {\n    constructor () public {\n        gov = msg.sender;\n        policies[0] = \"Put Option\";\n        policies[1] = \"Call Option\";\n        policies[2] = \"American Option\";\n        policies[3] = \"European Option\";\n        policies[4] = \"Asian Option\";\n        policies[5] = \"Barrier Option\";\n        policies[6] = \"Binary Option\";\n        policies[7] = \"Compound Option\";\n        policies[8] = \"Rainbow Option\";\n        policies[9] = \"Lookback Option\";\n        policies[10] = \"Forward Start Option\";\n        policies[11] = \"Chooser Option\";\n        policies[12] = \"Exchange Option\";\n        policies[13] = \"Quanto Option\";\n        policies[14] = \"Basket Option\";\n        policies[15] = \"Spread Option\";\n\n    }\n    mapping (uint => string) public policies;\n    function getAIPCPolicy(\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        uint256 _sizeDelta,\n        uint256 _collateralDelta\n    ) external view returns (uint256, string memory) {\n        if (_isLong) {\n            return (0, policies[0]);\n        } else {\n            return (1, policies[1]);\n        }\n    }\n\n    function setPolicy(uint _policyId, string memory _policy) external onlyGov {\n        policies[_policyId] = _policy;\n    }\n\n    function getPolicy(uint _policyId) external view returns (string memory) {\n        return policies[_policyId];\n    }\n}\n"
    },
    "contracts/core/v2/HedgeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\nimport \"./HedgeManagerSettings.sol\";\ncontract HedgeManager is HedgeManagerSettings{\n    constructor (address _aipcAddress) public {\n        aipc = AIPC(_aipcAddress);\n    }\n    function createHedgePolicy(\n        bytes32 _key,\n        uint _policyId\n    ) public {\n        hedges[_key].policyId = _policyId;\n        hedges[_key].lastIncreasedTime = block.timestamp;\n    }\n\n    function getPolicyFromKey(bytes32 _key) external view returns(Hedge memory) {\n        return hedges[_key];\n    }\n\n    function getPolicyMessageById(uint256 _policyId) external view returns(string memory) {\n        return aipc.getPolicy(_policyId);\n    }\n\n    function getPolicyFromAIPC(\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        uint256 _sizeDelta,\n        uint256 _collateralDelta\n    ) external view returns (uint256, string memory) {\n        return aipc.getAIPCPolicy(\n            _collateralToken,\n            _indexToken,\n            _isLong,\n            _sizeDelta,\n            _collateralDelta);\n    }\n}\n"
    },
    "contracts/core/v2/HedgeManagerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./AIPC.sol\";\nabstract contract HedgeManagerSettings {\n    struct Hedge {\n        uint256 policyId;\n        uint256 lastIncreasedTime;\n    }\n    mapping(bytes32 => Hedge) public hedges;\n    AIPC public aipc;\n}\n"
    },
    "contracts/core/v2/ZKHLPManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./ZKHLPManagerSettings.sol\";\n\ncontract ZKHLPManager is ZKHLPManagerSettings{\n    constructor (address _vault, address _zkhlp, address _zkusd, uint256 _cooldownDuration) public {\n        gov = msg.sender;\n        vault = IVault(_vault);\n        zkhlp = _zkhlp;\n        zkusd = _zkusd;\n        cooldownDuration = _cooldownDuration;\n    }\n\n    function addLiquidityForAccount(\n        address _fundingAccount, address _account,\n        address _token, uint256 _amount)\n    external returns (uint256) {\n        _validateHandler();\n        return _addLiquidity(_fundingAccount, _account, _token, _amount);\n    }\n\n    function removeLiquidityForAccount(\n        address _account, address _tokenOut, uint256 _zkhlpAmount, address _receiver\n    ) external returns (uint256){\n        _validateHandler();\n        return _removeLiquidity(_account, _tokenOut, _zkhlpAmount, _receiver);\n    }\n\n    function _validateHandler() internal view {\n        require(isHandler[msg.sender], Errors.ZKDLPMANAGER_FORBIDDEN);\n    }\n\n    function _addLiquidity(\n        address _fundingAccount, address _account,\n        address _token, uint256 _amount)\n    internal returns(uint256) {\n        require(_amount > 0, Errors.ZKDLPMANAGER_INVALID_AMOUNT);\n\n        IERC20(_token).safeTransferFrom(_fundingAccount, address(vault), _amount);\n        uint256 mintAmount = vault.buyZKUSD(_token, address(this));\n\n        IMintable(zkhlp).mint(_account, mintAmount);\n        return mintAmount;\n    }\n\n    function _removeLiquidity(\n        address _account, address _tokenOut,\n        uint256 _zkhlpAmount, address _receiver\n    ) internal returns(uint256) {\n        require(_zkhlpAmount > 0, Errors.ZKDLPMANAGER_INVALID_ZKDLPAMOUNT);\n\n        IMintable(zkhlp).burn(_account, _zkhlpAmount);\n        IERC20(zkusd).transfer(address(vault), _zkhlpAmount);\n        uint256 amountOut = vault.sellZKUSD(_tokenOut, _receiver);\n        return amountOut;\n    }\n}\n"
    },
    "contracts/core/v2/ZKHLPManagerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../interfaces/IVault.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../access/Governable.sol\";\nimport \"../../tokens/interfaces/IMintable.sol\";\n\nabstract contract ZKHLPManagerSettings is Governable{\n    // constructor\n    IVault public vault;\n    address public zkhlp;\n    address public zkusd;\n    uint256 public cooldownDuration;\n\n    mapping (address => bool) public isHandler;\n\n    /* misc */\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n}\n"
    },
    "contracts/core/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./settings/VaultInternal.sol\";\n\ncontract Vault is VaultInternal {\n    constructor() public {\n        gov = msg.sender;\n    }\n    function initialize(address _router, address _zkusd, address _priceFeed, uint256 _liquidationFeeUsd, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external {\n        _onlyGov();\n        _validate(!isInitialized, 1);\n        isInitialized = true;\n        router = _router;\n        zkusd = _zkusd;\n        priceFeed = _priceFeed;\n        liquidationFeeUsd = _liquidationFeeUsd;\n        fundingRateFactor = _fundingRateFactor;\n        stableFundingRateFactor = _stableFundingRateFactor;\n    }\n\n    function clearTokenConfig(address _token) external override {\n        _onlyGov();\n        _validate(whitelistedTokens[_token], 13);\n        totalTokenWeights = totalTokenWeights.sub(tokenWeights[_token]);\n        delete whitelistedTokens[_token];\n        delete tokenDecimals[_token];\n        delete tokenWeights[_token];\n        delete minProfitBasisPoints[_token];\n        delete maxZkusdAmounts[_token];\n        delete stableTokens[_token];\n        delete shortableTokens[_token];\n        whitelistedTokenCount = whitelistedTokenCount.sub(1);\n    }\n\n    function withdrawFees(address _token, address _receiver) external override returns (uint256) {\n        _onlyGov();\n        uint256 amount = feeReserves[_token];\n        if (amount == 0) {return 0;}\n        feeReserves[_token] = 0;\n        _transferOut(_token, amount, _receiver);\n        return amount;\n    }\n\n    function directPoolDeposit(address _token) external override nonReentrant {\n        _validate(whitelistedTokens[_token], 14);\n        uint256 tokenAmount = _transferIn(_token);\n        _validate(tokenAmount > 0, 15);\n        _increasePoolAmount(_token, tokenAmount);\n        emit Events.DirectPoolDeposit(_token, tokenAmount);\n    }\n\n    /**\n        * @param _token token to buy zkUSD with\n        * @param _receiver receiver of zkUSD\n        * @return mintAmount amount of zkUSD minted\n    */\n    function buyZKUSD(address _token, address _receiver) external override nonReentrant returns (uint256) {\n        _validateManager();\n        _validate(whitelistedTokens[_token], 16);\n        uint256 tokenAmount = _transferIn(_token);\n        _validate(tokenAmount > 0, 17);\n        updateCumulativeFundingRate(_token, _token);\n        uint256 price = getMinPrice(_token);\n        uint256 zkusdAmount = tokenAmount.mul(price).div(Constants.PRICE_PRECISION);\n        zkusdAmount = adjustForDecimals(zkusdAmount, _token, zkusd);\n        _validate(zkusdAmount > 0, 18);\n        uint256 feeBasisPoints = vaultUtils.getBuyZkusdFeeBasisPoints(_token, zkusdAmount);\n        uint256 amountAfterFees = _collectSwapFees(_token, tokenAmount, feeBasisPoints);\n        uint256 mintAmount = amountAfterFees.mul(price).div(Constants.PRICE_PRECISION);\n        mintAmount = adjustForDecimals(mintAmount, _token, zkusd);\n        _increaseZkusdAmount(_token, mintAmount);\n        _increasePoolAmount(_token, amountAfterFees);\n        IZKUSD(zkusd).mint(_receiver, mintAmount);\n        emit Events.BuyZKUSD(_receiver, _token, tokenAmount, mintAmount, feeBasisPoints);\n        return mintAmount;\n    }\n\n    /**\n        * @param _token token to sell zkUSD for\n        * @param _receiver receiver of token\n        * @return amountOut amount of token received\n    */\n\n    function sellZKUSD(address _token, address _receiver) external override nonReentrant returns (uint256) {\n        _validateManager();\n        _validate(whitelistedTokens[_token], 19);\n        uint256 zkusdAmount = _transferIn(zkusd);\n        _validate(zkusdAmount > 0, 20);\n        updateCumulativeFundingRate(_token, _token);\n        uint256 redemptionAmount = getRedemptionAmount(_token, zkusdAmount);\n        _validate(redemptionAmount > 0, 21);\n        _decreaseZkusdAmount(_token, zkusdAmount);\n        _decreasePoolAmount(_token, redemptionAmount);\n        IZKUSD(zkusd).burn(address(this), zkusdAmount);\n        _updateTokenBalance(zkusd);\n\n        uint256 feeBasisPoints = vaultUtils.getSellZkusdFeeBasisPoints(_token, zkusdAmount);\n        uint256 amountOut = _collectSwapFees(_token, redemptionAmount, feeBasisPoints);\n        _validate(amountOut > 0, 22);\n        _transferOut(_token, amountOut, _receiver);\n        emit Events.SellZKUSD(_receiver, _token, zkusdAmount, amountOut, feeBasisPoints);\n        return amountOut;\n    }\n\n    /**\n        * @param _tokenIn token to swap from\n        * @param _tokenOut token to swap to\n        * @param _receiver receiver of token\n        * @return amountOut amount of token received\n    */\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external override nonReentrant returns (uint256) {\n        _validate(isSwapEnabled, 23);\n        _validate(whitelistedTokens[_tokenIn], 24);\n        _validate(whitelistedTokens[_tokenOut], 25);\n        _validate(_tokenIn != _tokenOut, 26);\n        updateCumulativeFundingRate(_tokenIn, _tokenIn);\n        updateCumulativeFundingRate(_tokenOut, _tokenOut);\n        uint256 amountIn = _transferIn(_tokenIn);\n        _validate(amountIn > 0, 27);\n        uint256 priceIn = getMinPrice(_tokenIn);\n        uint256 priceOut = getMaxPrice(_tokenOut);\n        uint256 amountOut = amountIn.mul(priceIn).div(priceOut);\n        amountOut = adjustForDecimals(amountOut, _tokenIn, _tokenOut);\n        uint256 zkusdAmount = amountIn.mul(priceIn).div(Constants.PRICE_PRECISION);\n        zkusdAmount = adjustForDecimals(zkusdAmount, _tokenIn, zkusd);\n        uint256 feeBasisPoints = vaultUtils.getSwapFeeBasisPoints(_tokenIn, _tokenOut, zkusdAmount);\n        uint256 amountOutAfterFees = _collectSwapFees(_tokenOut, amountOut, feeBasisPoints);\n\n        _increaseZkusdAmount(_tokenIn, zkusdAmount);\n        _decreaseZkusdAmount(_tokenOut, zkusdAmount);\n        _increasePoolAmount(_tokenIn, amountIn);\n        _decreasePoolAmount(_tokenOut, amountOut);\n        _validateBufferAmount(_tokenOut);\n        _transferOut(_tokenOut, amountOutAfterFees, _receiver);\n        emit Events.Swap(_receiver, _tokenIn, _tokenOut, amountIn, amountOut, amountOutAfterFees, feeBasisPoints);\n        return amountOutAfterFees;\n    }\n\n    /**\n        * @param _account account to increase position for\n        * @param _collateralToken token to use as collateral\n        * @param _indexToken token to use as index\n        * @param _sizeDelta size to increase position by\n        * @param _isLong true if long, false if short\n    */\n    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external override nonReentrant {\n        _validate(isLeverageEnabled, 28);\n        _validateGasPrice();\n        _validateRouter(_account);\n        _validateTokens(_collateralToken, _indexToken, _isLong);\n        vaultUtils.validateIncreasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position storage position = positions[key];\n        uint256 price = _isLong ? getMaxPrice(_indexToken) : getMinPrice(_indexToken);\n        if (position.size == 0) {\n            position.averagePrice = price;\n        }\n        if (position.size > 0 && _sizeDelta > 0) {\n            position.averagePrice = getNextAveragePrice(_indexToken, position.size, position.averagePrice, _isLong, price, _sizeDelta, position.lastIncreasedTime);\n        }\n\n        uint256 fee = _collectMarginFees(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, position.size, position.entryFundingRate);\n        uint256 collateralDelta = _transferIn(_collateralToken);\n        uint256 collateralDeltaUsd = tokenToUsdMin(_collateralToken, collateralDelta);\n\n        position.collateral = position.collateral.add(collateralDeltaUsd);\n        _validate(position.collateral >= fee, 29);\n        position.collateral = position.collateral.sub(fee);\n        position.entryFundingRate = getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n        position.size = position.size.add(_sizeDelta);\n        position.lastIncreasedTime = block.timestamp;\n\n        _validate(position.size > 0, 30);\n        _validatePosition(position.size, position.collateral);\n        validateLiquidation(_account, _collateralToken, _indexToken, _isLong, true);\n\n        uint256 reserveDelta = usdToTokenMax(_collateralToken, _sizeDelta);\n        position.reserveAmount = position.reserveAmount.add(reserveDelta);\n        _increaseReservedAmount(_collateralToken, reserveDelta);\n        if (_isLong) {\n            _increaseGuaranteedUsd(_collateralToken, _sizeDelta.add(fee));\n            _decreaseGuaranteedUsd(_collateralToken, collateralDeltaUsd);\n            _increasePoolAmount(_collateralToken, collateralDelta);\n            _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, fee));\n        } else {\n            if (globalShortSizes[_indexToken] == 0) {\n                globalShortAveragePrices[_indexToken] = price;\n            } else {\n                globalShortAveragePrices[_indexToken] = getNextGlobalShortAveragePrice(_indexToken, price, _sizeDelta);\n            }\n\n            _increaseGlobalShortSize(_indexToken, _sizeDelta);\n        }\n        emit Events.IncreasePosition(key, _account, _collateralToken, _indexToken, collateralDeltaUsd, _sizeDelta, _isLong, price, fee);\n        emit Events.UpdatePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl, price);\n    }\n\n    /**\n        * @param _account account to decrease position for\n        * @param _collateralToken token to use as collateral\n        * @param _indexToken token to use as index\n        * @param _collateralDelta amount of collateral to withdraw\n        * @param _sizeDelta size to decrease position by\n        * @param _isLong true if long, false if short\n        * @param _receiver receiver of tokens\n        * @return amountOut amount of tokens received\n    */\n    function decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external override nonReentrant returns (uint256) {\n        _validateGasPrice();\n        _validateRouter(_account);\n        return _decreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n    }\n\n    /**\n        * @param _account account to close position for\n        * @param _collateralToken token to use as collateral\n        * @param _indexToken token to use as index\n        * @param _isLong true if long, false if short\n        * @param _feeReceiver receiver of tokens\n    */\n    function liquidatePosition(address _account, address _collateralToken, address _indexToken, bool _isLong, address _feeReceiver) external override nonReentrant returns (uint256) {\n        if (inPrivateLiquidationMode) {\n            _validate(isLiquidator[msg.sender], 34);\n        }\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position memory position = positions[key];\n        _validate(position.size > 0, 35);\n        (uint256 liquidationState, uint256 marginFees) = validateLiquidation(_account, _collateralToken, _indexToken, _isLong, false);\n        _validate(liquidationState != 0, 36);\n        if (liquidationState == 2) {\n            return _decreasePosition(_account, _collateralToken, _indexToken, 0, position.size, _isLong, msg.sender);  // liq\n        }\n        uint256 feeTokens = usdToTokenMin(_collateralToken, marginFees);\n        feeReserves[_collateralToken] = feeReserves[_collateralToken].add(feeTokens);\n        emit Events.CollectMarginFees(_collateralToken, marginFees, feeTokens);\n        _decreaseReservedAmount(_collateralToken, position.reserveAmount);\n\n        if (_isLong) {\n            _decreaseGuaranteedUsd(_collateralToken, position.size.sub(position.collateral));\n            _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, marginFees));\n        }\n        uint256 markPrice = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n        emit Events.LiquidatePosition(key, _account, _collateralToken, _indexToken, _isLong, position.size, position.collateral, position.reserveAmount, position.realisedPnl, markPrice);\n        if (!_isLong && marginFees < position.collateral) {\n            uint256 remainingCollateral = position.collateral.sub(marginFees);\n            _increasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, remainingCollateral));\n        }\n        if (!_isLong) {\n            _decreaseGlobalShortSize(_indexToken, position.size);\n        }\n        delete positions[key];\n        _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, liquidationFeeUsd));\n        _transferOut(_collateralToken, usdToTokenMin(_collateralToken, liquidationFeeUsd), _feeReceiver);\n        return 0;\n    }\n\n    function updateCumulativeFundingRate(address _collateralToken, address _indexToken) public {\n        bool shouldUpdate = vaultUtils.updateCumulativeFundingRate(_collateralToken, _indexToken);\n        if (!shouldUpdate) {\n            return;\n        }\n        if (lastFundingTimes[_collateralToken] == 0) {\n            lastFundingTimes[_collateralToken] = block.timestamp.div(fundingInterval).mul(fundingInterval);\n            return;\n        }\n        if (lastFundingTimes[_collateralToken].add(fundingInterval) > block.timestamp) {\n            return;\n        }\n        uint256 fundingRate = getNextFundingRate(_collateralToken);\n        cumulativeFundingRates[_collateralToken] = cumulativeFundingRates[_collateralToken].add(fundingRate);\n        lastFundingTimes[_collateralToken] = block.timestamp.div(fundingInterval).mul(fundingInterval);\n        emit Events.UpdateFundingRate(_collateralToken, cumulativeFundingRates[_collateralToken]);\n    }\n\n    function _decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) internal returns (uint256) {\n        vaultUtils.validateDecreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position storage position = positions[key];\n        _validate(position.size > 0, 31);\n        _validate(position.size >= _sizeDelta, 32);\n        _validate(position.collateral >= _collateralDelta, 33);\n\n        uint256 collateral = position.collateral;\n        {\n            uint256 reserveDelta = position.reserveAmount.mul(_sizeDelta).div(position.size);\n            position.reserveAmount = position.reserveAmount.sub(reserveDelta);\n            _decreaseReservedAmount(_collateralToken, reserveDelta);\n        }\n        (uint256 usdOut, uint256 usdOutAfterFee) = _reduceCollateral(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong);\n        if (position.size != _sizeDelta) {\n            position.entryFundingRate = getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n            position.size = position.size.sub(_sizeDelta);\n            _validatePosition(position.size, position.collateral);\n            validateLiquidation(_account, _collateralToken, _indexToken, _isLong, true);\n            if (_isLong) {\n                _increaseGuaranteedUsd(_collateralToken, collateral.sub(position.collateral));\n                _decreaseGuaranteedUsd(_collateralToken, _sizeDelta);\n            }\n            uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n            emit Events.DecreasePosition(key, _account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, price, usdOut.sub(usdOutAfterFee));\n            emit Events.UpdatePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl, price);\n        } else {\n            if (_isLong) {\n                _increaseGuaranteedUsd(_collateralToken, collateral);\n                _decreaseGuaranteedUsd(_collateralToken, _sizeDelta);\n            }\n            uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n            emit Events.DecreasePosition(key, _account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, price, usdOut.sub(usdOutAfterFee));\n            emit Events.ClosePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl);\n            delete positions[key];\n        }\n        if (!_isLong) {\n            _decreaseGlobalShortSize(_indexToken, _sizeDelta);\n        }\n        if (usdOut > 0) {\n            if (_isLong) {\n                _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, usdOut));\n            }\n            uint256 amountOutAfterFees = usdToTokenMin(_collateralToken, usdOutAfterFee);\n            _transferOut(_collateralToken, amountOutAfterFees, _receiver);\n            return amountOutAfterFees;\n        }\n        return 0;\n    }\n}\n"
    },
    "contracts/core/VaultErrorController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/IVault.sol\";\nimport \"../access/Governable.sol\";\ncontract VaultErrorController is Governable {\n    function setErrors(IVault _vault, string[] calldata _errors) external onlyGov {\n        for (uint256 i = 0; i < _errors.length; i++) {\n            _vault.setError(i, _errors[i]);\n        }\n    }\n}"
    },
    "contracts/core/VaultUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./storage/VaultUtilsStorage.sol\";\ncontract VaultUtils is VaultUtilsStorage {\n    constructor(IVault _vault) public {\n        vault = _vault;\n    }\n    function updateCumulativeFundingRate(address,address) public override returns (bool) {\n        return true;\n    }\n    function validateIncreasePosition(address,address,address,uint256,bool) external override view {\n    }\n    function validateDecreasePosition(address,address,address,uint256,uint256,bool,address) external override view {\n    }\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) public view override returns (uint256, uint256) {\n        DataTypes.Position memory position = getPosition(_account, _collateralToken, _indexToken, _isLong);\n        IVault _vault = vault;\n        (bool hasProfit, uint256 delta) = _vault.getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n        uint256 marginFees = getFundingFee(_account, _collateralToken, _indexToken, _isLong, position.size, position.entryFundingRate);\n        marginFees = marginFees.add(getPositionFee(_account, _collateralToken, _indexToken, _isLong, position.size));\n        if (!hasProfit && position.collateral < delta) {\n            if (_raise) { revert(Errors.VAULT_LOSSES_EXCEED_COLLATERAL); }\n            return (1, marginFees);\n        }\n        uint256 remainingCollateral = position.collateral;\n        if (!hasProfit) {\n            remainingCollateral = position.collateral.sub(delta);\n        }\n        if (remainingCollateral < marginFees) {\n            if (_raise) { revert(Errors.VAULT_FEES_EXCEED_COLLATERAL); }\n            return (1, remainingCollateral);\n        }\n        if (remainingCollateral < marginFees.add(_vault.liquidationFeeUsd())) {\n            if (_raise) { revert(Errors.VAULT_LIQUIDATION_FEES_EXCEED_COLLATERAL); }\n            return (1, marginFees);\n        }\n        if (remainingCollateral.mul(_vault.maxLeverage()) < position.size.mul(Constants.BASIS_POINTS_DIVISOR)) {\n            if (_raise) { revert(Errors.VAULT_MAXLEVERAGE_EXCEEDED); }\n            return (2, marginFees);\n        }\n        return (0, marginFees);\n    }\n    function getEntryFundingRate(address _collateralToken,address, bool) public override view returns (uint256) {\n        return vault.cumulativeFundingRates(_collateralToken);\n    }\n    function getPositionFee(address,address,address,bool,uint256 _sizeDelta) public override view returns (uint256) {\n        if (_sizeDelta == 0) { return 0; }\n        uint256 afterFeeUsd = _sizeDelta.mul(Constants.BASIS_POINTS_DIVISOR.sub(vault.marginFeeBasisPoints())).div(Constants.BASIS_POINTS_DIVISOR);\n        return _sizeDelta.sub(afterFeeUsd);\n    }\n    function getFundingFee(address, address _collateralToken, address,bool,uint256 _size, uint256 _entryFundingRate) public override view returns (uint256) {\n        if (_size == 0) { return 0; }\n        uint256 fundingRate = vault.cumulativeFundingRates(_collateralToken).sub(_entryFundingRate);\n        if (fundingRate == 0) { return 0; }\n        return _size.mul(fundingRate).div(Constants.FUNDING_RATE_PRECISION);\n    }\n    function getBuyZkusdFeeBasisPoints(address _token, uint256 _zkusdAmount) public override view returns (uint256) {\n        return getFeeBasisPoints(_token, _zkusdAmount, vault.mintBurnFeeBasisPoints(), vault.taxBasisPoints(), true);\n    }\n    function getSellZkusdFeeBasisPoints(address _token, uint256 _zkusdAmount) public override view returns (uint256) {\n        return getFeeBasisPoints(_token, _zkusdAmount, vault.mintBurnFeeBasisPoints(), vault.taxBasisPoints(), false);\n    }\n    function getSwapFeeBasisPoints(address _tokenIn, address _tokenOut, uint256 _zkusdAmount) public override view returns (uint256) {\n        bool isStableSwap = vault.stableTokens(_tokenIn) && vault.stableTokens(_tokenOut);\n        uint256 baseBps = isStableSwap ? vault.stableSwapFeeBasisPoints() : vault.swapFeeBasisPoints();\n        uint256 taxBps = isStableSwap ? vault.stableTaxBasisPoints() : vault.taxBasisPoints();\n        uint256 feesBasisPoints0 = getFeeBasisPoints(_tokenIn, _zkusdAmount, baseBps, taxBps, true);\n        uint256 feesBasisPoints1 = getFeeBasisPoints(_tokenOut, _zkusdAmount, baseBps, taxBps, false);\n        return feesBasisPoints0 > feesBasisPoints1 ? feesBasisPoints0 : feesBasisPoints1;\n    }\n    function getFeeBasisPoints(address _token, uint256 _zkusdDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) public override view returns (uint256) {\n        if (!vault.hasDynamicFees()) { return _feeBasisPoints; }\n        uint256 initialAmount = vault.zkusdAmounts(_token);\n        uint256 nextAmount = initialAmount.add(_zkusdDelta);\n        if (!_increment) {\n            nextAmount = _zkusdDelta > initialAmount ? 0 : initialAmount.sub(_zkusdDelta);\n        }\n        uint256 targetAmount = vault.getTargetZkusdAmount(_token);\n        if (targetAmount == 0) { return _feeBasisPoints; }\n        uint256 initialDiff = initialAmount > targetAmount ? initialAmount.sub(targetAmount) : targetAmount.sub(initialAmount);\n        uint256 nextDiff = nextAmount > targetAmount ? nextAmount.sub(targetAmount) : targetAmount.sub(nextAmount);\n        if (nextDiff < initialDiff) {\n            uint256 rebateBps = _taxBasisPoints.mul(initialDiff).div(targetAmount);\n            return rebateBps > _feeBasisPoints ? 0 : _feeBasisPoints.sub(rebateBps);\n        }\n        uint256 averageDiff = initialDiff.add(nextDiff).div(2);\n        if (averageDiff > targetAmount) {\n            averageDiff = targetAmount;\n        }\n        uint256 taxBps = _taxBasisPoints.mul(averageDiff).div(targetAmount);\n        return _feeBasisPoints.add(taxBps);\n    }\n    function getPosition(address _account, address _collateralToken, address _indexToken, bool _isLong) internal view returns (DataTypes.Position memory) {\n        IVault _vault = vault;\n        DataTypes.Position memory position;\n        {\n            (uint256 size, uint256 collateral, uint256 averagePrice, uint256 entryFundingRate, , , , uint256 lastIncreasedTime) = _vault.getPosition(_account, _collateralToken, _indexToken, _isLong);\n            position.size = size;\n            position.collateral = collateral;\n            position.averagePrice = averagePrice;\n            position.entryFundingRate = entryFundingRate;\n            position.lastIncreasedTime = lastIncreasedTime;\n        }\n        return position;\n    }\n}"
    },
    "contracts/core/ZkdlpManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./settings/ZkdlpManagerSettings.sol\";\n\ncontract ZkdlpManager is ZkdlpManagerSettings {\n    constructor(\n        address _vault, address _zkusd,\n        address _zkdlp, address _shortsTracker, uint256 _cooldownDuration) public {\n        gov = msg.sender;\n        vault = IVault(_vault);\n        zkUsd = _zkusd;\n        zkdlp = _zkdlp;\n        shortsTracker = IShortsTracker(_shortsTracker);\n        cooldownDuration = _cooldownDuration;\n    }\n//    function addLiquidity(address _token, uint256 _amount, uint256 _minZkusd, uint256 _minZkdlp) external override nonReentrant returns (uint256) {\n//        if (inPrivateMode) {revert(Errors.ZKDLPMANAGER_ACTION_NOT_ENABLED);}\n//        return _addLiquidity(msg.sender, msg.sender, _token, _amount, _minZkusd, _minZkdlp);\n//    }\n\n    /**\n        * @param _fundingAccount The account that will fund the liquidity\n        * @param _account The account that will receive the zkDLP tokens\n        * @param _token The token to add liquidity for\n        * @param _amount The amount of tokens to add liquidity for\n        * @param _minZkusd The minimum amount of zkUSD to receive\n        * @param _minZkdlp The minimum amount of zkDLP to receive\n        * @return The amount of zkDLP tokens minted\n    */\n    function addLiquidityForAccount(\n        address _fundingAccount, address _account,\n        address _token, uint256 _amount,\n        uint256 _minZkusd, uint256 _minZkdlp)\n    external override nonReentrant returns (uint256) {\n        _validateHandler();\n        return _addLiquidity(_fundingAccount, _account, _token, _amount, _minZkusd, _minZkdlp);\n    }\n\n//    function removeLiquidity(\n//        address _tokenOut, uint256 _zkdlpAmount,\n//        uint256 _minOut, address _receiver)\n//    external override nonReentrant returns (uint256) {\n//        if (inPrivateMode) {revert(Errors.ZKDLPMANAGER_ACTION_NOT_ENABLED);}\n//        return _removeLiquidity(msg.sender, _tokenOut, _zkdlpAmount, _minOut, _receiver);\n//    }\n\n    /**\n        * @param _account The account that will receive the liquidity\n        * @param _tokenOut The token to remove liquidity for\n        * @param _zkdlpAmount The amount of zkDLP tokens to remove liquidity for\n        * @param _minOut The minimum amount of tokens to receive\n        * @param _receiver The account that will receive the tokens\n        * @return The amount of tokens received\n    */\n    function removeLiquidityForAccount(\n        address _account, address _tokenOut,\n        uint256 _zkdlpAmount, uint256 _minOut, address _receiver)\n    external override nonReentrant returns (uint256) {\n        _validateHandler();\n        return _removeLiquidity(_account, _tokenOut, _zkdlpAmount, _minOut, _receiver);\n    }\n\n    function _addLiquidity(\n        address _fundingAccount, address _account,\n        address _token, uint256 _amount,\n        uint256 _minZkusd, uint256 _minZkdlp)\n    internal returns (uint256) {\n        require(_amount > 0, Errors.ZKDLPMANAGER_INVALID_AMOUNT);\n        uint256 aumInZkusd = getAumInZkusd(true);\n        uint256 zkdlpSupply = IERC20(zkdlp).totalSupply();\n        IERC20(_token).safeTransferFrom(_fundingAccount, address(vault), _amount);\n        uint256 zkusdAmount = vault.buyZKUSD(_token, address(this));\n        require(zkusdAmount >= _minZkusd, Errors.ZKDLPMANAGER_INSUFFICIENT_ZKUSD_OUTPUT);\n        uint256 mintAmount = aumInZkusd == 0 || zkdlpSupply == 0 ? zkusdAmount : zkusdAmount.mul(zkdlpSupply).div(aumInZkusd);\n        require(mintAmount >= _minZkdlp, Errors.ZKDLPMANAGER_INSUFFICIENT_ZKDLP_OUTPUT);\n        IMintable(zkdlp).mint(_account, mintAmount);\n        lastAddedAt[_account] = block.timestamp;\n        emit Events.AddLiquidity(_account, _token, _amount, aumInZkusd, zkdlpSupply, zkusdAmount, mintAmount);\n        return mintAmount;\n    }\n\n    function _removeLiquidity(\n        address _account, address _tokenOut,\n        uint256 _zkdlpAmount, uint256 _minOut,\n        address _receiver)\n    internal returns (uint256) {\n        require(_zkdlpAmount > 0, Errors.ZKDLPMANAGER_INVALID_ZKDLPAMOUNT);\n        require(lastAddedAt[_account].add(cooldownDuration) <= block.timestamp, Errors.ZKDLPMANAGER_COOLDOWN_DURATION_NOT_YET_PASSED);\n        uint256 aumInZkusd = getAumInZkusd(false);\n        uint256 zkdlpSupply = IERC20(zkdlp).totalSupply();\n        uint256 zkusdAmount = _zkdlpAmount.mul(aumInZkusd).div(zkdlpSupply);\n        uint256 zkusdBalance = IERC20(zkUsd).balanceOf(address(this));\n        if (zkusdAmount > zkusdBalance) {\n            IZKUSD(zkUsd).mint(address(this), zkusdAmount.sub(zkusdBalance));\n        }\n        IMintable(zkdlp).burn(_account, _zkdlpAmount);\n        IERC20(zkUsd).transfer(address(vault), zkusdAmount);\n        uint256 amountOut = vault.sellZKUSD(_tokenOut, _receiver);\n        require(amountOut >= _minOut, Errors.ZKDLPMANAGER_INSUFFICIENT_OUTPUT);\n        emit Events.RemoveLiquidity(_account, _tokenOut, _zkdlpAmount, aumInZkusd, zkdlpSupply, zkusdAmount, amountOut);\n        return amountOut;\n    }\n\n    function _validateHandler() internal view {\n        require(isHandler[msg.sender], Errors.ZKDLPMANAGER_FORBIDDEN);\n    }\n\n    function getPrice(bool _maximise) external view returns (uint256) {\n        uint256 supply = IERC20(zkdlp).totalSupply();\n        if (supply == 0) return Constants.PRICE_PRECISION;\n\n        uint256 aum = getAum(_maximise, false);\n        return aum.mul(Constants.ZKDLP_PRECISION).div(supply);\n    }\n\n    function getAums() public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = getAum(true, false);\n        amounts[1] = getAum(false, false);\n        return amounts;\n    }\n\n    function getAumInZkusd(bool maximise) public override view returns (uint256) {\n        uint256 aum = getAum(maximise, true);\n        return aum.mul(10 ** Constants.ZKUSD_DECIMALS).div(Constants.PRICE_PRECISION);\n    }\n\n    function getAum(bool maximise, bool fresh) public view returns (uint256) {\n        uint256 length = vault.allWhitelistedTokensLength();\n        uint256 aum = aumAddition;\n        uint256 shortProfits = 0;\n\n        IVault _vault = vault;\n        IVaultPriceFeed _priceFeed = IVaultPriceFeed(vault.priceFeed());\n\n        for (uint256 i = 0; i < length; i++) {\n            address token = vault.allWhitelistedTokens(i);\n            if (!vault.whitelistedTokens(token))\n                continue;\n\n            uint256 price;\n            if (vault.equityTokens(token) || vault.stableTokens(token))\n                price = _priceFeed.getPrice(token, true, maximise, false);\n            else\n                price = _priceFeed.getPrice(token, true, maximise, fresh);\n\n            uint256 poolAmount = _vault.poolAmounts(token);\n            uint256 decimals = _vault.tokenDecimals(token);\n            if (_vault.stableTokens(token)) {\n                aum = aum.add(poolAmount.mul(price).div(10 ** decimals));\n            } else {\n                uint256 size = _vault.globalShortSizes(token);\n                if (size > 0) {\n                    (uint256 delta, bool hasProfit) = getGlobalShortDelta(token, price, size);\n                    if (!hasProfit) {\n                        aum = aum.add(delta);\n                    } else {\n                        shortProfits = shortProfits.add(delta);\n                    }\n                }\n                aum = aum.add(_vault.guaranteedUsd(token));\n                uint256 reservedAmount = _vault.reservedAmounts(token);\n                aum = aum.add(poolAmount.sub(reservedAmount).mul(price).div(10 ** decimals));\n            }\n        }\n        aum = shortProfits > aum ? 0 : aum.sub(shortProfits);\n        return aumDeduction > aum ? 0 : aum.sub(aumDeduction);\n    }\n\n    function getGlobalShortDelta(address _token, uint256 _price, uint256 _size) public view returns (uint256, bool) {\n        uint256 averagePrice = getGlobalShortAveragePrice(_token);\n        uint256 priceDelta = averagePrice > _price ? averagePrice.sub(_price) : _price.sub(averagePrice);\n        uint256 delta = _size.mul(priceDelta).div(averagePrice);\n        return (delta, averagePrice > _price);\n    }\n\n    function getGlobalShortAveragePrice(address _token) public view returns (uint256) {\n        IShortsTracker _shortsTracker = shortsTracker;\n        if (address(_shortsTracker) == address(0) || !_shortsTracker.isGlobalShortDataReady()) {\n            return vault.globalShortAveragePrices(_token);\n        }\n        uint256 _shortsTrackerAveragePriceWeight = shortsTrackerAveragePriceWeight;\n        if (_shortsTrackerAveragePriceWeight == 0) {\n            return vault.globalShortAveragePrices(_token);\n        } else if (_shortsTrackerAveragePriceWeight == Constants.BASIS_POINTS_DIVISOR) {\n            return _shortsTracker.globalShortAveragePrices(_token);\n        }\n        uint256 vaultAveragePrice = vault.globalShortAveragePrices(_token);\n        uint256 shortsTrackerAveragePrice = _shortsTracker.globalShortAveragePrices(_token);\n        return vaultAveragePrice.mul(Constants.BASIS_POINTS_DIVISOR.sub(_shortsTrackerAveragePriceWeight)).add(shortsTrackerAveragePrice.mul(_shortsTrackerAveragePriceWeight)).div(Constants.BASIS_POINTS_DIVISOR);\n    }\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nlibrary Constants {\n    /* BASE */\n    string public constant ZKDX_ID = \"ZKDX\";\n    string public constant ZKDX_TOKEN_NAME = \"ZKDX\";\n    string public constant ZKDX_TOKEN_SYMBOL = \"ZKDX\";\n    string public constant ZKDLP_ID = \"ZKDLP\";\n    string public constant ZKDLP_TOKEN_NAME = \"ZKDLP\";\n    string public constant ZKDLP_TOKEN_SYMBOL = \"ZKDLP\";\n\n    string public constant ZKUSD_TOKEN_NAME = \"ZKUSD\";\n    string public constant ZKUSD_TOKEN_SYMBOL = \"ZKUSD\";\n    /* VaultPriceFeed.sol */\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant ONE_USD = PRICE_PRECISION;\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant MAX_SPREAD_BASIS_POINTS = 50;\n    uint256 public constant MAX_ADJUSTMENT_INTERVAL = 2 hours;\n    uint256 public constant MAX_ADJUSTMENT_BASIS_POINTS = 20;\n    address constant internal FLAG_ARBITRUM_SEQ_OFFLINE = address(bytes20(bytes32(uint256(keccak256(\"chainlink.flags.arbitrum-seq-offline\")) - 1)));\n    /* VaultUtils.sol */\n    uint256 public constant FUNDING_RATE_PRECISION = 1000000;\n\n    /* Vault.sol*/\n    uint256 public constant MIN_LEVERAGE = 10000; // 1x\n    uint256 public constant ZKUSD_DECIMALS = 18;\n    uint256 public constant MAX_FEE_BASIS_POINTS = 500; // 5%\n    uint256 public constant MAX_LIQUIDATION_FEE_USD = 100 * PRICE_PRECISION; // 100 USD\n\n    /* OrderBook.sol */\n    uint256 public constant ZKUSD_PRECISION = 1e18;\n\n    /* ZKDLP.sol */\n    uint256 public constant ZKDLP_PRECISION = 10 ** 18;\n    uint256 public constant MAX_COOLDOWN_DURATION = 48 hours;\n\n    /* ShortsTracker */\n    uint256 public constant MAX_INT256 = uint256(type(int256).max);\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nlibrary DataTypes {\n    struct IncreaseOrder {\n        address account;\n        address purchaseToken;\n        uint256 purchaseTokenAmount;\n        address collateralToken;\n        address indexToken;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 triggerPrice;\n        bool triggerAboveThreshold;\n        uint256 executionFee;\n    }\n    struct DecreaseOrder {\n        address account;\n        address collateralToken;\n        uint256 collateralDelta;\n        address indexToken;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 triggerPrice;\n        bool triggerAboveThreshold;\n        uint256 executionFee;\n    }\n    struct SwapOrder {\n        address account;\n        address[] path;\n        uint256 amountIn;\n        uint256 minOut;\n        uint256 triggerRatio;\n        bool triggerAboveThreshold;\n        bool shouldUnwrap;\n        uint256 executionFee;\n    }\n\n    /* Vault.sol */\n    struct Position {\n        uint256 size;\n        uint256 collateral;\n        uint256 averagePrice; // col average price\n        uint256 entryFundingRate;\n        uint256 reserveAmount;\n        int256 realisedPnl;\n        uint256 lastIncreasedTime;\n    }\n}"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nlibrary Errors {\n    /* Timelock Error Message*/\n    string public constant Timelock_Invalid_Target = \"Timelock: invalid _target\";\n    string public constant Timelock_Invalid_Buffer = \"Timelock: invalid _buffer\";\n    string public constant Timelock_Buffer_Cannot_Be_Decreased = \"Timelock: buffer cannot be decreased\";\n    string public constant Timelock_invalid_maxLeverage = \"Timelock: invalid _maxLeverage\";\n    string public constant Timelock_invalid_fundingRateFactor = \"Timelock: invalid _fundingRateFactor\";\n    string public constant Timelock_invalid_stableFundingRateFactor = \"Timelock: invalid _stableFundingRateFactor\";\n    string public constant TIMELOCK_INVALID_MAXGASPRICE = \"Invalid _maxGasPrice\";\n    string public constant TIMELOCK_INVALID_LENGTHS = \"Timelock: invalid lengths\";\n    string public constant TIMELOCK_MAXTOKENSUPPLY_EXCEEDED = \"Timelock: maxTokenSupply exceeded\";\n    string public constant TIMELOCK_ACTION_ALREADY_SIGNALLED = \"Timelock: action already signalled\";\n    string public constant TIMELOCK_ACTION_NOT_SIGNALLED = \"Timelock: action not signalled\";\n    string public constant TIMELOCK_ACTION_TIME_NOT_YET_PASSED = \"Timelock: action time not yet passed\";\n    string public constant TIMELOCK_INVALID_ACTION = \"Timelock: invalid _action\";\n    string public constant TIMELOCK_INVALID_BUFFER = \"Timelock: invalid _buffer\";\n    /* ZKUSD.sol*/\n    string public constant ZKUSD_FORBIDDEN = \"ZKUSD: forbidden\";\n    /* BasePositionManagers.sol */\n    string public constant BASEPOSITIONMANAGER_MARK_PRICE_LOWER_THAN_LIMIT      = \"BasePositionManager: mark price lower than limit\";\n    string public constant BASEPOSITIONMANAGER_MARK_PRICE_HIGHER_THAN_LIMIT     = \"BasePositionManager: mark price higher than limit\";\n    string public constant BASEPOSITIONMANAGER_INVALID_PATH_LENGTH              = \"BasePositionManager: invalid _path.length\";\n    string public constant BASEPOSITIONMANAGER_INSUFFICIENT_AMOUNTOUT           = \"BasePositionManager: insufficient amountOut\";\n    string public constant BASEPOSITIONMANAGER_MAX_GLOBAL_LONGS_EXCEEDED        = \"BasePositionManager: max global longs exceeded\";\n    string public constant BASEPOSITIONMANAGER_MAX_GLOBAL_SHORTS_EXCEEDED       = \"BasePositionManager: max global shorts exceeded\";\n    string public constant BASEPOSITIONMANAGER_INVALID_SENDER                   = \"BasePositionManager: invalid sender\";\n    string public constant BASEPOSITIONMANAGER_TRANSFER_OUT_FAILED              = \"BasePositionManager: failed to transfer out ether\";\n    /* PositionManager.sol */\n    string public constant POSITIONMANAGER_INVALID_PATH_LENGTH                  = \"PositionManager: invalid _path.length\";\n    string public constant POSITIONMANAGER_INVALID_PATH                         = \"PositionManager: invalid _path\";\n    string public constant POSITIONMANAGER_LONG_DEPOSIT                         = \"PositionManager: long deposit\";\n    string public constant POSITIONMANAGER_LONG_LEVERAGE_DECREASE               = \"PositionManager: long leverage decrease\";\n    string public constant POSITIONMANAGER_FORBIDDEN                            = \"PositionManager: forbidden\";\n    string public constant POSITIONMANAGER_INSUFFICIENT_FEE                     = \"PositionManager: insufficient fee\";\n    /* Router.sol*/\n    string public constant ROUTER_FORBIDDEN                                     = \"Router: forbidden\";\n    /* ZkdlpManager.sol */\n    string public constant ZKDLPMANAGER_ACTION_NOT_ENABLED                      = \"ZkdlpManager: action not enabled\";\n    string public constant ZKDLPMANAGER_INVALID_WEIGHT                          = \"ZkdlpManager: invalid weight\";\n    string public constant ZKDLPMANAGER_INVALID_COOLDOWNDURATION                = \"ZkdlpManager: invalid _cooldownDuration\";\n    string public constant ZKDLPMANAGER_INVALID_AMOUNT                          = \"ZkdlpManager: invalid _amount\";\n    string public constant ZKDLPMANAGER_INSUFFICIENT_ZKUSD_OUTPUT               = \"ZkdlpManager: insufficient ZKUSD output\";\n    string public constant ZKDLPMANAGER_INSUFFICIENT_ZKDLP_OUTPUT               = \"ZkdlpManager: insufficient ZKDLP output\";\n    string public constant ZKDLPMANAGER_INVALID_ZKDLPAMOUNT                     = \"ZkdlpManager: invalid _ZKDLPAmount\";\n    string public constant ZKDLPMANAGER_COOLDOWN_DURATION_NOT_YET_PASSED        = \"ZkdlpManager: cooldown duration not yet passed\";\n    string public constant ZKDLPMANAGER_INSUFFICIENT_OUTPUT                     = \"ZkdlpManager: insufficient output\";\n    string public constant ZKDLPMANAGER_FORBIDDEN                               = \"ZkdlpManager: forbidden\";\n    /* ShortsTrack.sol*/\n    string public constant SHORTSTRACKER_FORBIDDEN                              = \"ShortsTracker: forbidden\";\n    string public constant SHORTSTRACKER_INVALID_HANDLER                        = \"ShortsTracker: invalid _handler\";\n    string public constant SHORTSTRACKER_ALREADY_MIGRATED                       = \"ShortsTracker: already migrated\";\n    string public constant SHORTSTRACKER_OVERFLOW                               = \"ShortsTracker: overflow\";\n    /* VaultUtils.sol*/\n    string public constant VAULT_LOSSES_EXCEED_COLLATERAL                       = \"Vault: losses exceed collateral\";\n    string public constant VAULT_FEES_EXCEED_COLLATERAL                         = \"Vault: fees exceed collateral\";\n    string public constant VAULT_LIQUIDATION_FEES_EXCEED_COLLATERAL             = \"Vault: liquidation fees exceed collateral\";\n    string public constant VAULT_MAXLEVERAGE_EXCEEDED                           = \"Vault: maxLeverage exceeded\";\n    /* VaultInternal.sol*/\n    string internal constant VAULT_POOLAMOUNT_EXCEEDED                          = \"Vault: poolAmount exceeded\";\n    string internal constant VAULT_INSUFFICIENT_RESERVE                         = \"Vault: insufficient reserve\";\n    string internal constant VAULT_MAX_SHORTS_EXCEEDED                          = \"Vault: max shorts exceeded\";\n    string internal constant VAULT_POOLAMOUNT_BUFFER                            = \"Vault: poolAmount < buffer\";\n    string internal constant VAULT_INVALID_ERRORCONTROLLER                      = \"Vault: invalid errorController\";\n    /* Router.sol */\n    string internal constant ROUTER_INVALID_SENDER                              = \"Router: invalid sender\";\n    string internal constant ROUTER_INVALID_PATH                                = \"Router: invalid _path\";\n    string internal constant ROUTER_MARK_PRICE_HIGHER_THAN_LIMIT                = \"Router: mark price higher than limit\";\n    string internal constant ROUTER_MARK_PRICE_LOWER_THAN_LIMIT                 = \"Router: mark price lower than limit\";\n    string internal constant ROUTER_INVALID_PATH_LENGTH                         = \"Router: invalid _path.length\";\n    string internal constant ROUTER_INSUFFICIENT_AMOUNTOUT                      = \"Router: insufficient amountOut\";\n    string internal constant ROUTER_INVALID_PLUGIN                              = \"Router: invalid plugin\";\n    /* OrderBook.sol*/\n    string internal constant ORDERBOOK_FORBIDDEN                                = \"OrderBook: forbidden\";\n    string internal constant ORDERBOOK_ALREADY_INITIALIZED                      = \"OrderBook: already initialized\";\n    string internal constant ORDERBOOK_INVALID_SENDER                           = \"OrderBook: invalid sender\";\n    string internal constant ORDERBOOK_INVALID_PATH_LENGTH                      = \"OrderBook: invalid _path.length\";\n    string internal constant ORDERBOOK_INVALID_PATH                             = \"OrderBook: invalid _path\";\n    string internal constant ORDERBOOK_INVALID_AMOUNTIN                         = \"OrderBook: invalid _amountIn\";\n    string internal constant ORDERBOOK_INSUFFICIENT_EXECUTION_FEE               = \"OrderBook: insufficient execution fee\";\n    string internal constant ORDERBOOK_ONLY_WETH_COULD_BE_WRAPPED               = \"OrderBook: only weth could be wrapped\";\n    string internal constant ORDERBOOK_INCORRECT_VALUE_TRANSFERRED              = \"OrderBook: incorrect value transferred\";\n    string internal constant ORDERBOOK_INCORRECT_EXECUTION_FEE_TRANSFERRED      = \"OrderBook: incorrect execution fee transferred\";\n    string internal constant ORDERBOOK_NON_EXISTENT_ORDER                       = \"OrderBook: non-existent order\";\n    string internal constant ORDERBOOK_INVALID_PRICE_FOR_EXECUTION              = \"OrderBook: invalid price for execution\";\n    string internal constant ORDERBOOK_INSUFFICIENT_COLLATERAL                  = \"OrderBook: insufficient collateral\";\n    string internal constant ORDERBOOK_INSUFFICIENT_AMOUNTOUT                   = \"OrderBook: insufficient amountOut\";\n    /* RewardRouterV2.sol */\n    string internal constant REWARDROUTER_INVALID_AMOUNT                        = \"RewardRouter: invalid _amount\";\n    string internal constant REWARDROUTER_INVALID_MSG_VALUE                     = \"RewardRouter: invalid msg.value\";\n    string internal constant REWARDROUTER_ALREADY_INITIALIZED                   = \"RewardRouter: already initialized\";\n    string internal constant REWARDROUTER_INVALID_ZKUSDAMOUNT                   = \"RewardRouter: invalid _zkusdAmount\";\n\n    /* YieldToken.sol */\n    string public constant YIELDTOKEN_ACCOUNT_ALREADY_MARKED                    = \"YieldToken: _account already marked\";\n    string public constant YIELDTOKEN_ACCOUNT_NOT_MARKED                        = \"YieldToken: _account not marked\";\n    string public constant YIELDTOKEN_TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE         = \"YieldToken: transfer amount exceeds allowance\";\n    string public constant YIELDTOKEN_MINT_TO_THE_ZERO_ADDRESS                  = \"YieldToken: mint to the zero address\";\n    string public constant YIELDTOKEN_BURN_FROM_THE_ZERO_ADDRESS                = \"YieldToken: burn from the zero address\";\n    string public constant YIELDTOKEN_BURN_AMOUNT_EXCEEDS_BALANCE               = \"YieldToken: burn amount exceeds balance\";\n    string public constant YIELDTOKEN_TRANSFER_FROM_THE_ZERO_ADDRESS            = \"YieldToken: transfer from the zero address\";\n    string public constant YIELDTOKEN_TRANSFER_TO_THE_ZERO_ADDRESS              = \"YieldToken: transfer to the zero address\";\n    string public constant YIELDTOKEN_MSG_SENDER_NOT_WHITELISTED                = \"YieldToken: msg.sender not whitelisted\";\n    string public constant YIELDTOKEN_TRANSFER_AMOUNT_EXCEEDS_BALANCE           = \"YieldToken: transfer amount exceeds balance\";\n    string public constant YIELDTOKEN_APPROVE_FROM_THE_ZERO_ADDRESS             = \"YieldToken: approve from the zero address\";\n    string public constant YIELDTOKEN_APPROVE_TO_THE_ZERO_ADDRESS               = \"YieldToken: approve to the zero address\";\n\n    string public constant MINTABLEBASETOKEN_FORBIDDEN                          = \"MintableBaseToken: forbidden\";\n    string public constant BASETOKEN_FORBIDDEN                                  = \"BaseToken: forbidden\";\n    string public constant BASETOKEN_ACCOUNT_ALREADY_MARKED                     = \"BaseToken: _account already marked\";\n    string public constant BASETOKEN_ACCOUNT_NOT_MARKED                         = \"BaseToken: _account not marked\";\n    string public constant BASETOKEN_TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE          = \"BaseToken: transfer amount exceeds allowance\";\n    string public constant BASETOKEN_MINT_TO_THE_ZERO_ADDRESS                   = \"BaseToken: mint to the zero address\";\n    string public constant BASETOKEN_BURN_FROM_THE_ZERO_ADDRESS                 = \"BaseToken: burn from the zero address\";\n    string public constant BASETOKEN_BURN_AMOUNT_EXCEEDS_BALANCE                = \"BaseToken: burn amount exceeds balance\";\n    string public constant BASETOKEN_TRANSFER_FROM_THE_ZERO_ADDRESS             = \"BaseToken: transfer from the zero address\";\n    string public constant BASETOKEN_TRANSFER_TO_THE_ZERO_ADDRESS               = \"BaseToken: transfer to the zero address\";\n    string public constant BASETOKEN_MSG_SENDER_NOT_WHITELISTED                 = \"BaseToken: msg.sender not whitelisted\";\n    string public constant BASETOKEN_TRANSFER_AMOUNT_EXCEEDS_BALANCE            = \"BaseToken: transfer amount exceeds balance\";\n    string public constant BASETOKEN_APPROVE_FROM_THE_ZERO_ADDRESS              = \"BaseToken: approve from the zero address\";\n    string public constant BASETOKEN_APPROVE_TO_THE_ZERO_ADDRESS                = \"BaseToken: approve to the zero address\";\n}\n"
    },
    "contracts/libraries/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nlibrary Events {\n    /* BasePositionManager Events */\n    event SetDepositFee(uint256 depositFee);\n    event SetIncreasePositionBufferBps(uint256 increasePositionBufferBps);\n    event SetAdmin(address admin);\n    event WithdrawFees(address token, address receiver, uint256 amount);\n    event SetMaxGlobalSizes(address[] tokens, uint256[] longSizes, uint256[] shortSizes);\n    /*Position Manager Events*/\n    event SetOrderKeeper(address indexed account, bool isActive);\n    event SetLiquidator(address indexed account, bool isActive);\n    event SetPartner(address account, bool isActive);\n    event SetOpened(bool opened);\n    event SetShouldValidateIncreaseOrder(bool shouldValidateIncreaseOrder);\n    /* Orderbook.sol events */\n    event CreateSwapOrder(\n        address indexed account, uint256 orderIndex,\n        address[] path, uint256 amountIn, uint256 minOut,\n        uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n    event CancelSwapOrder(\n        address indexed account, uint256 orderIndex,\n        address[] path, uint256 amountIn, uint256 minOut,\n        uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n    event UpdateSwapOrder(\n        address indexed account, uint256 ordexIndex, address[] path, uint256 amountIn, uint256 minOut, uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n    event ExecuteSwapOrder(\n        address indexed account, uint256 orderIndex,\n        address[] path, uint256 amountIn, uint256 minOut,\n        uint256 amountOut, uint256 triggerRatio,\n        bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n    event Initialize(\n        address router, address vault, address weth,\n        address zkusd, uint256 minExecutionFee);\n    event UpdateMinExecutionFee(uint256 minExecutionFee);\n    event UpdateGov(address gov);\n    /* Router.sol events*/\n    event Swap(address account, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut);\n    /* ShortsTracker.sol events*/\n    event GlobalShortDataUpdated(address indexed token, uint256 globalShortSize, uint256 globalShortAveragePrice);\n    /* Vault.sol events */\n    event BuyZKUSD(\n        address account, address token,\n        uint256 tokenAmount, uint256 zkusdAmount, uint256 feeBasisPoints);\n    event SellZKUSD(\n        address account, address token,\n        uint256 zkusdAmount, uint256 tokenAmount, uint256 feeBasisPoints);\n    event Swap(\n        address account, address tokenIn,\n        address tokenOut, uint256 amountIn,\n        uint256 amountOut, uint256 amountOutAfterFees,\n        uint256 feeBasisPoints);\n    event IncreasePosition(\n        bytes32 key, address account,\n        address collateralToken, address indexToken,\n        uint256 collateralDelta, uint256 sizeDelta,\n        bool isLong, uint256 price, uint256 fee);\n    event DecreasePosition(\n        bytes32 key, address account,\n        address collateralToken, address indexToken,\n        uint256 collateralDelta, uint256 sizeDelta,\n        bool isLong, uint256 price, uint256 fee);\n    event LiquidatePosition(\n        bytes32 key, address account, address collateralToken,\n        address indexToken, bool isLong, uint256 size,\n        uint256 collateral, uint256 reserveAmount, int256 realisedPnl, uint256 markPrice);\n    event UpdatePosition(\n        bytes32 key, uint256 size, uint256 collateral,\n        uint256 averagePrice, uint256 entryFundingRate,\n        uint256 reserveAmount, int256 realisedPnl, uint256 markPrice);\n    event ClosePosition(\n        bytes32 key, uint256 size, uint256 collateral,\n        uint256 averagePrice, uint256 entryFundingRate, uint256 reserveAmount, int256 realisedPnl);\n    event UpdateFundingRate(address token, uint256 fundingRate);\n    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);\n    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event DirectPoolDeposit(address token, uint256 amount);\n    event IncreasePoolAmount(address token, uint256 amount);\n    event DecreasePoolAmount(address token, uint256 amount);\n    event IncreaseZkusdAmount(address token, uint256 amount);\n    event DecreaseZkusdAmount(address token, uint256 amount);\n    event IncreaseReservedAmount(address token, uint256 amount);\n    event DecreaseReservedAmount(address token, uint256 amount);\n    event IncreaseGuaranteedUsd(address token, uint256 amount);\n    event DecreaseGuaranteedUsd(address token, uint256 amount);\n    /* Timelock.sol events */\n    event SignalPendingAction(bytes32 action);\n    event SignalApprove(address token, address spender, uint256 amount, bytes32 action);\n    event SignalWithdrawToken(address target, address token, address receiver, uint256 amount, bytes32 action);\n    event SignalMint(address token, address receiver, uint256 amount, bytes32 action);\n    event SignalSetGov(address target, address gov, bytes32 action);\n    event SignalSetHandler(address target, address handler, bool isActive, bytes32 action);\n    event SignalSetPriceFeed(address vault, address priceFeed, bytes32 action);\n    event SignalRedeemZkusd(address vault, address token, uint256 amount);\n    event SignalVaultSetTokenConfig(\n        address vault, address token, uint256 tokenDecimals,\n        uint256 tokenWeight, uint256 minProfitBps, uint256 maxZkusdAmount,\n        bool isStable, bool isShortable);\n    event ClearAction(bytes32 action);\n    /* ZkdlpManager.sol */\n    event AddLiquidity(address account, address token, uint256 amount, uint256 aumInUsd, uint256 zkdlpSupply, uint256 zkusdAmount, uint256 mintAmount);\n    event RemoveLiquidity(address account, address token, uint256 zkdlpAmount, uint256 aumInUsd, uint256 zkdlpSupply, uint256 zkusdAmount, uint256 amountOut);\n    /* RewardRouterV2 */\n    event StakeZkdx(address account, address token, uint256 amount);\n    event UnstakeZkdx(address account, address token, uint256 amount);\n    event StakeZkdlp(address account, uint256 amount);\n    event UnstakeZkdlp(address account, uint256 amount);\n\n    /* OrderBook.sol */\n    event CreateIncreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n\n    event CancelIncreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n\n    event ExecuteIncreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee,\n        uint256 executionPrice\n    );\n\n    event UpdateIncreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        address indexToken,\n        bool isLong,\n        uint256 sizeDelta,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold\n    );\n\n    event CreateDecreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n\n    event CancelDecreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n\n    event ExecuteDecreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee,\n        uint256 executionPrice\n    );\n\n    event UpdateDecreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold\n    );\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/libraries/token/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IERC20.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/mock/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract Token is IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    address private _owner;\n    uint256 public interval;\n    uint256 public faucetTotal;\n    uint256 public faucetAmount;\n    uint256 public giveawayTotal;\n    bool public openMint = false;\n\n    mapping(address => uint256) accountLastTime;\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory _n, uint8 _dc, uint256 _faucetTotal, uint256 _faucetAmount, uint256 _interval) public {\n        _name = _n;\n        _symbol = _n;\n        _decimals = _dc;\n        interval = _interval;\n        faucetTotal = _faucetTotal;\n        faucetAmount = _faucetAmount;\n        _owner = msg.sender;\n    }\n\n    function mint(address account, uint256 amount) public {\n        if (!openMint)\n            require(_owner == _msgSender(), \"Caller is not the owner\");\n        _mint(account, amount);\n    }\n\n    function faucet() external {\n        require(faucetAmount > 0, \"Faucet is not enabled now.\");\n        require(faucetTotal >= giveawayTotal + faucetAmount, \"Faucet is running out now.\");\n        require(block.timestamp - accountLastTime[msg.sender] >= interval, \"Faucet interval is not expired.\");\n\n        giveawayTotal += faucetAmount;\n        accountLastTime[msg.sender] = block.timestamp;\n        _mint(msg.sender, faucetAmount);\n    }\n\n    function withdrawToken(address token, address account, uint256 amount) public {\n        IERC20(token).transfer(account, amount);\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount, \"Token: insufficient balance\");\n        _burn(msg.sender, amount);\n        (bool sent,) = msg.sender.call{value : amount}(\"\");\n        require(sent, \"failed to send ether\");\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function setFaucetAmount(uint256 _faucetAmount) external onlyOwner {\n        faucetAmount = _faucetAmount;\n    }\n\n    function setInterval(uint256 _inverval) external onlyOwner {\n        interval = _inverval;\n    }\n\n    function setFaucetTotal(uint256 _faucetTotal) external {\n        faucetTotal = _faucetTotal;\n    }\n\n    function setOpenMint(bool open) external {\n        openMint = open;\n    }\n\n    function burn(address account, uint256 amount) external onlyOwner {\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/peripherals/interfaces/IHandlerTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IHandlerTarget {\n    function isHandler(address _account) external returns (bool);\n    function setHandler(address _handler, bool _isActive) external;\n}"
    },
    "contracts/peripherals/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface ITimelock {\n    function setAdmin(address _admin) external;\n    function enableLeverage(address _vault) external;\n    function disableLeverage(address _vault) external;\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external;\n    function signalSetGov(address _target, address _gov) external;\n}"
    },
    "contracts/peripherals/interfaces/ITimelockTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface ITimelockTarget {\n    function setGov(address _gov) external;\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}"
    },
    "contracts/peripherals/OrderBookReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"../core/interfaces/IOrderBook.sol\";\n\ncontract OrderBookReader {\n    using SafeMath for uint256;\n\n    struct Vars {\n        uint256 i;\n        uint256 index;\n        address account;\n        uint256 uintLength;\n        uint256 addressLength;\n    }\n\n    function getIncreaseOrders(\n        address payable _orderBookAddress,\n        address _account,\n        uint256[] memory _indices\n    ) external view returns (uint256[] memory, address[] memory) {\n        Vars memory vars = Vars(0, 0, _account, 5, 3);\n\n        uint256[] memory uintProps = new uint256[](vars.uintLength * _indices.length);\n        address[] memory addressProps = new address[](vars.addressLength * _indices.length);\n\n        IOrderBook orderBook = IOrderBook(_orderBookAddress);\n\n        while (vars.i < _indices.length) {\n            vars.index = _indices[vars.i];\n            (\n                address purchaseToken,\n                uint256 purchaseTokenAmount,\n                address collateralToken,\n                address indexToken,\n                uint256 sizeDelta,\n                bool isLong,\n                uint256 triggerPrice,\n                bool triggerAboveThreshold,\n                // uint256 executionFee\n            ) = orderBook.getIncreaseOrder(vars.account, vars.index);\n\n            uintProps[vars.i * vars.uintLength] = uint256(purchaseTokenAmount);\n            uintProps[vars.i * vars.uintLength + 1] = uint256(sizeDelta);\n            uintProps[vars.i * vars.uintLength + 2] = uint256(isLong ? 1 : 0);\n            uintProps[vars.i * vars.uintLength + 3] = uint256(triggerPrice);\n            uintProps[vars.i * vars.uintLength + 4] = uint256(triggerAboveThreshold ? 1 : 0);\n\n            addressProps[vars.i * vars.addressLength] = (purchaseToken);\n            addressProps[vars.i * vars.addressLength + 1] = (collateralToken);\n            addressProps[vars.i * vars.addressLength + 2] = (indexToken);\n\n            vars.i++;\n        }\n\n        return (uintProps, addressProps);\n    }\n\n    function getDecreaseOrders(\n        address payable _orderBookAddress,\n        address _account,\n        uint256[] memory _indices\n    ) external view returns (uint256[] memory, address[] memory) {\n        Vars memory vars = Vars(0, 0, _account, 5, 2);\n\n        uint256[] memory uintProps = new uint256[](vars.uintLength * _indices.length);\n        address[] memory addressProps = new address[](vars.addressLength * _indices.length);\n\n        IOrderBook orderBook = IOrderBook(_orderBookAddress);\n\n        while (vars.i < _indices.length) {\n            vars.index = _indices[vars.i];\n            (\n                address collateralToken,\n                uint256 collateralDelta,\n                address indexToken,\n                uint256 sizeDelta,\n                bool isLong,\n                uint256 triggerPrice,\n                bool triggerAboveThreshold,\n                // uint256 executionFee\n            ) = orderBook.getDecreaseOrder(vars.account, vars.index);\n\n            uintProps[vars.i * vars.uintLength] = uint256(collateralDelta);\n            uintProps[vars.i * vars.uintLength + 1] = uint256(sizeDelta);\n            uintProps[vars.i * vars.uintLength + 2] = uint256(isLong ? 1 : 0);\n            uintProps[vars.i * vars.uintLength + 3] = uint256(triggerPrice);\n            uintProps[vars.i * vars.uintLength + 4] = uint256(triggerAboveThreshold ? 1 : 0);\n\n            addressProps[vars.i * vars.addressLength] = (collateralToken);\n            addressProps[vars.i * vars.addressLength + 1] = (indexToken);\n\n            vars.i++;\n        }\n\n        return (uintProps, addressProps);\n    }\n\n}\n"
    },
    "contracts/peripherals/Reader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../access/Governable.sol\";\nimport \"../core/storage/ReaderStorage.sol\";\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../core/interfaces/IBasePositionManager.sol\";\n\ncontract Reader is Governable, ReaderStorage {\n\n    function setConfig(bool _hasMaxGlobalShortSizes) public onlyGov {\n        hasMaxGlobalShortSizes = _hasMaxGlobalShortSizes;\n    }\n\n    function getVaultTokenInfo(address _vault, address _positionManager, address _weth, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 12;\n        IVault vault = IVault(_vault);\n        IBasePositionManager positionManager = IBasePositionManager(_positionManager);\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.zkusdAmounts(token);\n            amounts[i * propsLength + 3] = vault.tokenWeights(token);\n            amounts[i * propsLength + 4] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 5] = vault.maxZkusdAmounts(token);\n            amounts[i * propsLength + 6] = vault.globalShortSizes(token);\n            amounts[i * propsLength + 7] = positionManager.maxGlobalShortSizes(token);\n            amounts[i * propsLength + 8] = positionManager.maxGlobalLongSizes(token);\n            amounts[i * propsLength + 9] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 10] = vault.minProfitBasisPoints(token);\n            amounts[i * propsLength + 11] = vault.minProfitTime();\n        }\n        return amounts;\n    }\n\n    function getFeeBasisPoints(IVault _vault, address _tokenIn, address _tokenOut, uint256 _amountIn) public view returns (uint256, uint256, uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n        uint256 tokenInDecimals = _vault.tokenDecimals(_tokenIn);\n        uint256 zkusdAmount = _amountIn.mul(priceIn).div(PRICE_PRECISION);\n        zkusdAmount = zkusdAmount.mul(10 ** ZKUSD_DECIMALS).div(10 ** tokenInDecimals);\n        bool isStableSwap = _vault.stableTokens(_tokenIn) && _vault.stableTokens(_tokenOut);\n        uint256 baseBps = isStableSwap ? _vault.stableSwapFeeBasisPoints() : _vault.swapFeeBasisPoints();\n        uint256 taxBps = isStableSwap ? _vault.stableTaxBasisPoints() : _vault.taxBasisPoints();\n        uint256 feesBasisPoints0 = _vault.getFeeBasisPoints(_tokenIn, zkusdAmount, baseBps, taxBps, true);\n        uint256 feesBasisPoints1 = _vault.getFeeBasisPoints(_tokenOut, zkusdAmount, baseBps, taxBps, false);\n        uint256 feeBasisPoints = feesBasisPoints0 > feesBasisPoints1 ? feesBasisPoints0 : feesBasisPoints1;\n        return (feeBasisPoints, feesBasisPoints0, feesBasisPoints1);\n    }\n\n    function getFees(address _vault, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amounts[i] = IVault(_vault).feeReserves(_tokens[i]);\n        }\n        return amounts;\n    }\n\n    function getTotalStaked(address[] memory _yieldTokens) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_yieldTokens.length);\n        for (uint256 i = 0; i < _yieldTokens.length; i++) {\n            IYieldToken yieldToken = IYieldToken(_yieldTokens[i]);\n            amounts[i] = yieldToken.totalStaked();\n        }\n        return amounts;\n    }\n\n    function getStakingInfo(address _account, address[] memory _yieldTrackers) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory amounts = new uint256[](_yieldTrackers.length * propsLength);\n        for (uint256 i = 0; i < _yieldTrackers.length; i++) {\n            IYieldTracker yieldTracker = IYieldTracker(_yieldTrackers[i]);\n            amounts[i * propsLength] = yieldTracker.claimable(_account);\n            amounts[i * propsLength + 1] = yieldTracker.getTokensPerInterval();\n        }\n        return amounts;\n    }\n\n//    function getVestingInfo(address _account, address[] memory _vesters) public view returns (uint256[] memory) {\n//        uint256 propsLength = 7;\n//        uint256[] memory amounts = new uint256[](_vesters.length * propsLength);\n//        for (uint256 i = 0; i < _vesters.length; i++) {\n//            IVester vester = IVester(_vesters[i]);\n//            amounts[i * propsLength] = vester.pairAmounts(_account);\n//            amounts[i * propsLength + 1] = vester.getVestedAmount(_account);\n//            amounts[i * propsLength + 2] = IERC20(_vesters[i]).balanceOf(_account);\n//            amounts[i * propsLength + 3] = vester.claimedAmounts(_account);\n//            amounts[i * propsLength + 4] = vester.claimable(_account);\n//            amounts[i * propsLength + 5] = vester.getMaxVestableAmount(_account);\n//            amounts[i * propsLength + 6] = vester.getCombinedAverageStakedAmount(_account);\n//        }\n//        return amounts;\n//    }\n\n    function getFundingRates(address _vault, address _weth, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory fundingRates = new uint256[](_tokens.length * propsLength);\n        IVault vault = IVault(_vault);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            uint256 fundingRateFactor = vault.stableTokens(token) ? vault.stableFundingRateFactor() : vault.fundingRateFactor();\n            uint256 reservedAmount = vault.reservedAmounts(token);\n            uint256 poolAmount = vault.poolAmounts(token);\n            if (poolAmount > 0) {\n                fundingRates[i * propsLength] = fundingRateFactor.mul(reservedAmount).div(poolAmount);\n            }\n            if (vault.cumulativeFundingRates(token) > 0) {\n                uint256 nextRate = vault.getNextFundingRate(token);\n                uint256 baseRate = vault.cumulativeFundingRates(token);\n                fundingRates[i * propsLength + 1] = baseRate.add(nextRate);\n            }\n        }\n        return fundingRates;\n    }\n\n    function getTokenSupply(IERC20 _token, address[] memory _excludedAccounts) public view returns (uint256) {\n        uint256 supply = _token.totalSupply();\n        for (uint256 i = 0; i < _excludedAccounts.length; i++) {\n            address account = _excludedAccounts[i];\n            uint256 balance = _token.balanceOf(account);\n            supply = supply.sub(balance);\n        }\n        return supply;\n    }\n\n    function getTotalBalance(IERC20 _token, address[] memory _accounts) public view returns (uint256) {\n        uint256 totalBalance = 0;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 balance = _token.balanceOf(account);\n            totalBalance = totalBalance.add(balance);\n        }\n        return totalBalance;\n    }\n\n    function getTokenBalances(address _account, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i] = _account.balance;\n                continue;\n            }\n            balances[i] = IERC20(token).balanceOf(_account);\n        }\n        return balances;\n    }\n\n    function getTokenBalancesWithSupplies(address _account, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory balances = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i * propsLength] = _account.balance;\n                balances[i * propsLength + 1] = 0;\n                continue;\n            }\n            balances[i * propsLength] = IERC20(token).balanceOf(_account);\n            balances[i * propsLength + 1] = IERC20(token).totalSupply();\n        }\n        return balances;\n    }\n\n    function getPositions(address _vault, address _account, address[] memory _collateralTokens, address[] memory _indexTokens, bool[] memory _isLong) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_collateralTokens.length * POSITION_PROPS_LENGTH);\n        for (uint256 i = 0; i < _collateralTokens.length; i++) {\n            {\n                (uint256 size,\n                uint256 collateral,\n                uint256 averagePrice,\n                uint256 entryFundingRate,\n                /* reserveAmount */,\n                uint256 realisedPnl,\n                bool hasRealisedProfit,\n                uint256 lastIncreasedTime) = IVault(_vault).getPosition(_account, _collateralTokens[i], _indexTokens[i], _isLong[i]);\n\n                amounts[i * POSITION_PROPS_LENGTH] = size;\n                amounts[i * POSITION_PROPS_LENGTH + 1] = collateral;\n                amounts[i * POSITION_PROPS_LENGTH + 2] = averagePrice;\n                amounts[i * POSITION_PROPS_LENGTH + 3] = entryFundingRate;\n                amounts[i * POSITION_PROPS_LENGTH + 4] = hasRealisedProfit ? 1 : 0;\n                amounts[i * POSITION_PROPS_LENGTH + 5] = realisedPnl;\n                amounts[i * POSITION_PROPS_LENGTH + 6] = lastIncreasedTime;\n            }\n        }\n        return amounts;\n    }\n}\n"
    },
    "contracts/peripherals/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../core/storage/TimelockStorage.sol\";\n\ncontract Timelock is TimelockStorage {\n\n    constructor(address _admin, uint256 _buffer, address _tokenManager, address _mintReceiver, address _zkdlpManager, uint256 _maxTokenSupply, uint256 _marginFeeBasisPoints, uint256 _maxMarginFeeBasisPoints) public {\n        require(_buffer <= MAX_BUFFER, Errors.TIMELOCK_INVALID_BUFFER);\n        admin = _admin;\n        buffer = _buffer;\n        tokenManager = _tokenManager;\n        mintReceiver = _mintReceiver;\n        zkdlpManager = _zkdlpManager;\n        maxTokenSupply = _maxTokenSupply;\n\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        maxMarginFeeBasisPoints = _maxMarginFeeBasisPoints;\n    }\n    /* onlyAdmin */\n    function setAdmin(address _admin) external override onlyAdmin {\n        admin = _admin;\n    }\n\n    function setZkdlpManager(address _zkdlpManager) external onlyAdmin{\n        zkdlpManager = _zkdlpManager;\n    }\n\n    /* admin */\n    function setExternalAdmin(address _target, address _admin) external onlyAdmin {\n        require(_target != address(this), Errors.Timelock_Invalid_Target);\n        IAdmin(_target).setAdmin(_admin);\n    }\n\n    function setContractHandler(address _handler, bool _isActive) external onlyAdmin {\n        isHandler[_handler] = _isActive;\n    }\n\n    function setKeeper(address _keeper, bool _isActive) external onlyAdmin {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setBuffer(uint256 _buffer) external onlyAdmin {\n        require(_buffer <= MAX_BUFFER, Errors.Timelock_Invalid_Buffer);\n        require(_buffer > buffer, Errors.Timelock_Buffer_Cannot_Be_Decreased);\n        buffer = _buffer;\n    }\n\n    function setMaxLeverage(address _vault, uint256 _maxLeverage) external onlyAdmin {\n        IVault(_vault).setMaxLeverage(_maxLeverage);\n    }\n\n    function setMaxGlobalShortSize(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        IVault(_vault).setMaxGlobalShortSize(_token, _amount);\n    }\n\n    function setVaultUtils(address _vault, IVaultUtils _vaultUtils) external onlyAdmin {\n        IVault(_vault).setVaultUtils(_vaultUtils);\n    }\n\n    function setMaxGasPrice(address _vault, uint256 _maxGasPrice) external onlyAdmin {\n        require(_maxGasPrice > 5000000000, Errors.TIMELOCK_INVALID_MAXGASPRICE);\n        IVault(_vault).setMaxGasPrice(_maxGasPrice);\n    }\n\n    function setInPrivateLiquidationMode(address _vault, bool _inPrivateLiquidationMode) external onlyAdmin {\n        IVault(_vault).setInPrivateLiquidationMode(_inPrivateLiquidationMode);\n    }\n\n    function setLiquidator(address _vault, address _liquidator, bool _isActive) external onlyAdmin {\n        IVault(_vault).setLiquidator(_liquidator, _isActive);\n    }\n\n    function setInPrivateTransferMode(address _token, bool _inPrivateTransferMode) external onlyAdmin {\n        IBaseToken(_token).setInPrivateTransferMode(_inPrivateTransferMode);\n    }\n\n    function setGov(address _target, address _gov) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _validateAction(action);\n        _clearAction(action);\n        ITimelockTarget(_target).setGov(_gov);\n    }\n\n    function setHandler(address _target, address _handler, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setHandler\", _target, _handler, _isActive));\n        _validateAction(action);\n        _clearAction(action);\n        IHandlerTarget(_target).setHandler(_handler, _isActive);\n    }\n\n    function setPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed));\n        _validateAction(action);\n        _clearAction(action);\n        IVault(_vault).setPriceFeed(_priceFeed);\n    }\n\n    function removeAdmin(address _token, address _account) external onlyAdmin {\n        IYieldToken(_token).removeAdmin(_account);\n    }\n\n    function withdrawFees(address _vault, address _token, address _receiver) external onlyAdmin {\n        IVault(_vault).withdrawFees(_token, _receiver);\n    }\n\n    function transferIn(address _sender, address _token, uint256 _amount) external onlyAdmin {\n        IERC20(_token).transferFrom(_sender, address(this), _amount);\n    }\n\n    function signalApprove(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _setPendingAction(action);\n        emit Events.SignalApprove(_token, _spender, _amount, action);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    function signalWithdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit Events.SignalWithdrawToken(_target, _token, _receiver, _amount, action);\n    }\n\n    function withdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IBaseToken(_target).withdrawToken(_token, _receiver, _amount);\n    }\n\n    function signalMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"mint\", _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit Events.SignalMint(_token, _receiver, _amount, action);\n    }\n\n    function processMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"mint\", _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        _mint(_token, _receiver, _amount);\n    }\n\n    function signalSetGov(address _target, address _gov) external override onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _setPendingAction(action);\n        emit Events.SignalSetGov(_target, _gov, action);\n    }\n\n    function signalSetHandler(address _target, address _handler, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setHandler\", _target, _handler, _isActive));\n        _setPendingAction(action);\n        emit Events.SignalSetHandler(_target, _handler, _isActive, action);\n    }\n\n    function signalSetPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed));\n        _setPendingAction(action);\n        emit Events.SignalSetPriceFeed(_vault, _priceFeed, action);\n    }\n\n    function signalRedeemZkusd(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"redeemZkusd\", _vault, _token, _amount));\n        _setPendingAction(action);\n        emit Events.SignalRedeemZkusd(_vault, _token, _amount);\n    }\n\n    function redeemZkusd(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"redeemZkusd\", _vault, _token, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        address zkusd = IVault(_vault).zkusd();\n        IVault(_vault).setManager(address(this), true);\n        IZKUSD(zkusd).addVault(address(this));\n        IZKUSD(zkusd).mint(address(this), _amount);\n        IERC20(zkusd).transfer(address(_vault), _amount);\n        IVault(_vault).sellZKUSD(_token, mintReceiver);\n        IVault(_vault).setManager(address(this), false);\n        IZKUSD(zkusd).removeVault(address(this));\n    }\n\n    function cancelAction(bytes32 _action) external onlyAdmin {\n        _clearAction(_action);\n    }\n\n    /* onlyKeeperAndAbove */\n    function setFundingRate(address _vault, uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external onlyKeeperAndAbove {\n        require(_fundingRateFactor <= MAX_FUNDING_RATE_FACTOR, Errors.Timelock_invalid_fundingRateFactor);\n        require(_stableFundingRateFactor <= MAX_FUNDING_RATE_FACTOR, Errors.Timelock_invalid_stableFundingRateFactor);\n        IVault(_vault).setFundingRate(_fundingInterval, _fundingRateFactor, _stableFundingRateFactor);\n    }\n\n    function setSwapFees(\n        address _vault, uint256 _taxBasisPoints, uint256 _stableTaxBasisPoints, uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints, uint256 _stableSwapFeeBasisPoints) external onlyKeeperAndAbove {\n        IVault vault = IVault(_vault);\n        vault.setFees(\n            _taxBasisPoints,\n            _stableTaxBasisPoints,\n            _mintBurnFeeBasisPoints,\n            _swapFeeBasisPoints,\n            _stableSwapFeeBasisPoints,\n            maxMarginFeeBasisPoints,\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n    function setFees(\n        address _vault, uint256 _taxBasisPoints, uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints, uint256 _swapFeeBasisPoints, uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints, uint256 _liquidationFeeUsd, uint256 _minProfitTime, bool _hasDynamicFees) external onlyKeeperAndAbove {\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        IVault(_vault).setFees(\n            _taxBasisPoints,\n            _stableTaxBasisPoints,\n            _mintBurnFeeBasisPoints,\n            _swapFeeBasisPoints,\n            _stableSwapFeeBasisPoints,\n            maxMarginFeeBasisPoints,\n            _liquidationFeeUsd,\n            _minProfitTime,\n            _hasDynamicFees\n        );\n    }\n\n    function setMinProfitTime(address _vault, uint256 _minProfitTime) external onlyKeeperAndAbove {\n        IVault(_vault).setMinProfitTime(_minProfitTime);\n    }\n\n    function setTokenConfig(\n        address _vault,\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxZkusdAmount,\n        bool _isStable,\n        bool _isShortable,\n        bool _isEquity\n    ) external onlyKeeperAndAbove {\n        IVault(_vault).setTokenConfig(\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxZkusdAmount,\n            _isStable,\n            _isShortable,\n            _isEquity\n        );\n    }\n\n    function clearTokenConfig(address _vault, address _token) external {\n        IVault(_vault).clearTokenConfig(_token);\n    }\n\n    function setAllowStableEquity(address _vault, bool _allowStaleEquityPrice) external onlyKeeperAndAbove {\n        IVault(_vault).setAllowStableEquity(_allowStaleEquityPrice);\n    }\n\n    function setBufferAmounts(address _vault, address[] memory _tokens, uint256[] memory _bufferAmounts) external onlyKeeperAndAbove {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IVault(_vault).setBufferAmount(_tokens[i], _bufferAmounts[i]);\n        }\n    }\n\n    function setZkusdAmounts(address _vault, address[] memory _tokens, uint256[] memory _zkusdAmounts) external onlyKeeperAndAbove {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IVault(_vault).setZkusdAmount(_tokens[i], _zkusdAmounts[i]);\n        }\n    }\n\n    function setIsSwapEnabled(address _vault, bool _isSwapEnabled) external onlyKeeperAndAbove {\n        IVault(_vault).setIsSwapEnabled(_isSwapEnabled);\n    }\n\n    function updateZkusdSupply(uint256 zkusdAmount) external onlyKeeperAndAbove {\n        address zkusd = IZkdlpManager(zkdlpManager).zkUsd();\n        uint256 balance = IERC20(zkusd).balanceOf(zkdlpManager);\n        IZKUSD(zkusd).addVault(address(this));\n        if (zkusdAmount > balance) {\n            uint256 mintAmount = zkusdAmount.sub(balance);\n            IZKUSD(zkusd).mint(zkdlpManager, mintAmount);\n        } else {\n            uint256 burnAmount = balance.sub(zkusdAmount);\n            IZKUSD(zkusd).burn(zkdlpManager, burnAmount);\n        }\n        IZKUSD(zkusd).removeVault(address(this));\n    }\n\n\n\n    function batchWithdrawFees(address _vault, address[] memory _tokens) external onlyKeeperAndAbove {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IVault(_vault).withdrawFees(_tokens[i], admin);\n        }\n    }\n\n//    function batchSetBonusRewards(address _vester, address[] memory _accounts, uint256[] memory _amounts) external onlyKeeperAndAbove {\n//        require(_accounts.length == _amounts.length, Errors.TIMELOCK_INVALID_LENGTHS);\n//        if (!IHandlerTarget(_vester).isHandler(address(this))) {\n//            IHandlerTarget(_vester).setHandler(address(this), true);\n//        }\n//        for (uint256 i = 0; i < _accounts.length; i++) {\n//            address account = _accounts[i];\n//            uint256 amount = _amounts[i];\n//            IVester(_vester).setBonusRewards(account, amount);\n//        }\n//    }\n\n    /* onlyHandlerAndAbove */\n    function setShouldToggleIsLeverageEnabled(bool _shouldToggleIsLeverageEnabled) external onlyHandlerAndAbove {\n        shouldToggleIsLeverageEnabled = _shouldToggleIsLeverageEnabled;\n    }\n\n    function setMarginFeeBasisPoints(uint256 _marginFeeBasisPoints, uint256 _maxMarginFeeBasisPoints) external onlyHandlerAndAbove {\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        maxMarginFeeBasisPoints = _maxMarginFeeBasisPoints;\n    }\n\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external override onlyHandlerAndAbove {\n        IVault(_vault).setIsLeverageEnabled(_isLeverageEnabled);\n    }\n\n    function setZusd(address _vault, address _zusd) external onlyHandlerAndAbove {\n        IVault(_vault).setZusd(_zusd);\n    }\n\n    function enableLeverage(address _vault) external override onlyHandlerAndAbove {\n        IVault vault = IVault(_vault);\n        if (shouldToggleIsLeverageEnabled) {\n            vault.setIsLeverageEnabled(true);\n        }\n        vault.setFees(\n            vault.taxBasisPoints(),\n            vault.stableTaxBasisPoints(),\n            vault.mintBurnFeeBasisPoints(),\n            vault.swapFeeBasisPoints(),\n            vault.stableSwapFeeBasisPoints(),\n            marginFeeBasisPoints,\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n    function disableLeverage(address _vault) external override onlyHandlerAndAbove {\n        IVault vault = IVault(_vault);\n        if (shouldToggleIsLeverageEnabled) {\n            vault.setIsLeverageEnabled(false);\n        }\n        vault.setFees(\n            vault.taxBasisPoints(),\n            vault.stableTaxBasisPoints(),\n            vault.mintBurnFeeBasisPoints(),\n            vault.swapFeeBasisPoints(),\n            vault.stableSwapFeeBasisPoints(),\n            maxMarginFeeBasisPoints, // marginFeeBasisPoints\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n\n    /* private */\n    function _mint(address _token, address _receiver, uint256 _amount) private {\n        IMintable mintable = IMintable(_token);\n        if (!mintable.isMinter(address(this))) {\n            mintable.setMinter(address(this), true);\n        }\n        mintable.mint(_receiver, _amount);\n        require(IERC20(_token).totalSupply() <= maxTokenSupply, Errors.TIMELOCK_MAXTOKENSUPPLY_EXCEEDED);\n    }\n\n    function _setPendingAction(bytes32 _action) private {\n        require(pendingActions[_action] == 0, Errors.TIMELOCK_ACTION_ALREADY_SIGNALLED);\n        pendingActions[_action] = block.timestamp.add(buffer);\n        emit Events.SignalPendingAction(_action);\n    }\n\n    function _validateAction(bytes32 _action) private view {\n        require(pendingActions[_action] != 0, Errors.TIMELOCK_ACTION_NOT_SIGNALLED);\n        require(pendingActions[_action] < block.timestamp, Errors.TIMELOCK_ACTION_TIME_NOT_YET_PASSED);\n    }\n\n    function _clearAction(bytes32 _action) private {\n        require(pendingActions[_action] != 0, Errors.TIMELOCK_INVALID_ACTION);\n        delete pendingActions[_action];\n        emit Events.ClearAction(_action);\n    }\n}\n"
    },
    "contracts/staking/RewardRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../core/settings/RewardRouterV2Settings.sol\";\nimport \"../core/BasePriceConsumer.sol\";\ncontract RewardRouterV2 is RewardRouterV2Settings, BasePriceConsumer {\n\n    constructor(address _vault) public BasePriceConsumer(_vault) {}\n\n    receive() external payable {\n        require(msg.sender == weth, Errors.ROUTER_INVALID_SENDER);\n    }\n\n    /**\n        * @param _token address of the token to be staked\n        * @param _amount amount of the token to be staked\n        * @param _minZkUSD minimum amount of zkUSD to be minted\n        * @param _minZkdlp minimum amount of zkdlp to be minted\n        * @param _updateData array of bytes containing the data to be passed to the update function\n        * @return zkdlpAmount amount of zkdlp minted\n    */\n    function mintAndStakeZkdlp(\n        address _token,\n        uint256 _amount,\n        uint256 _minZkUSD,\n        uint256 _minZkdlp,\n        bytes[] calldata _updateData\n    ) external payable nonReentrant returns (uint256 zkdlpAmount) {\n        _update(_updateData);\n        require(_amount > 0, Errors.REWARDROUTER_INVALID_AMOUNT);\n        zkdlpAmount = IZkdlpManager(zkdlpManager).addLiquidityForAccount(msg.sender, msg.sender, _token, _amount, _minZkUSD, _minZkdlp);\n    }\n\n    /**\n        * @param _minZkusd minimum amount of zkUSD to be minted\n        * @param _minZkdlp minimum amount of zkdlp to be minted\n        * @param _updateData array of bytes containing the data to be passed to the update function\n        * @return zkdlpAmount amount of zkdlp minted\n    */\n    function mintAndStakeZkdlpETH(\n        uint256 _minZkusd,\n        uint256 _minZkdlp,\n        bytes[] calldata _updateData\n    ) external payable nonReentrant returns (uint256 zkdlpAmount) {\n        uint256 _fee = _update(_updateData);\n        uint256 _amountIn = msg.value.sub(_fee);\n        require(_amountIn > 0, Errors.REWARDROUTER_INVALID_MSG_VALUE);\n\n        IWETH(weth).deposit{value : _amountIn}();\n        IERC20(weth).approve(zkdlpManager, _amountIn);\n\n        zkdlpAmount = IZkdlpManager(zkdlpManager).addLiquidityForAccount(address(this), msg.sender, weth, _amountIn, _minZkusd, _minZkdlp);\n    }\n\n    /**\n        * @param _tokenOut address of the token to be unstaked\n        * @param _zkdlpAmount amount of zkdlp to be unstaked\n        * @param _minOut minimum amount of token to be received\n        * @param _receiver address of the receiver\n        * @param _updateData array of bytes containing the data to be passed to the update function\n        * @return amountOut amount of token received\n    */\n    function unstakeAndRedeemZkdlp(\n        address _tokenOut,\n        uint256 _zkdlpAmount,\n        uint256 _minOut,\n        address _receiver,\n        bytes[] calldata _updateData\n    ) external payable nonReentrant returns (uint256 amountOut) {\n        _update(_updateData);\n        require(_zkdlpAmount > 0, Errors.REWARDROUTER_INVALID_ZKUSDAMOUNT);\n\n        amountOut = IZkdlpManager(zkdlpManager).removeLiquidityForAccount(msg.sender, _tokenOut, _zkdlpAmount, _minOut, _receiver);\n        emit Events.UnstakeZkdlp(msg.sender, _zkdlpAmount);\n    }\n\n    /**\n        * @param _zkdlpAmount amount of zkdlp to be unstaked\n        * @param _minOut minimum amount of ETH to be received\n        * @param _receiver address of the receiver\n        * @param _updateData array of bytes containing the data to be passed to the update function\n        * @return amountOut amount of ETH received\n    */\n    function unstakeAndRedeemZkdlpETH(\n        uint256 _zkdlpAmount,\n        uint256 _minOut,\n        address payable _receiver,\n        bytes[] calldata _updateData\n    ) external payable nonReentrant returns (uint256 amountOut) {\n        _update(_updateData);\n        require(_zkdlpAmount > 0, Errors.REWARDROUTER_INVALID_ZKUSDAMOUNT);\n\n        amountOut = IZkdlpManager(zkdlpManager).removeLiquidityForAccount(msg.sender, weth, _zkdlpAmount, _minOut, address(this));\n        IWETH(weth).withdraw(amountOut);\n        _receiver.sendValue(amountOut);\n        emit Events.UnstakeZkdlp(msg.sender, _zkdlpAmount);\n    }\n}\n"
    },
    "contracts/tokens/base/BaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"./../interfaces/IYieldTracker.sol\";\nimport \"./../interfaces/IBaseToken.sol\";\nimport \"../../libraries/Errors.sol\";\n\ncontract BaseToken is IERC20, IBaseToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 public nonStakingSupply;\n    address public gov;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowances;\n    address[] public yieldTrackers;\n    mapping(address => bool) public nonStakingAccounts;\n    mapping(address => bool) public admins;\n    bool public inPrivateTransferMode;\n    mapping(address => bool) public isHandler;\n    modifier onlyGov() {\n        require(msg.sender == gov, Errors.BASETOKEN_FORBIDDEN);\n        _;\n    }\n    modifier onlyAdmin() {\n        require(admins[msg.sender], Errors.BASETOKEN_FORBIDDEN);\n        _;\n    }\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public {\n        name = _name;\n        symbol = _symbol;\n        gov = msg.sender;\n        _mint(msg.sender, _initialSupply);\n    }\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setInfo(string memory _name, string memory _symbol) external onlyGov {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function setYieldTrackers(address[] memory _yieldTrackers) external onlyGov {\n        yieldTrackers = _yieldTrackers;\n    }\n\n    function addAdmin(address _account) external onlyGov {\n        admins[_account] = true;\n    }\n\n    function removeAdmin(address _account) external override onlyGov {\n        admins[_account] = false;\n    }\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external override onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function setInPrivateTransferMode(bool _inPrivateTransferMode) external override onlyGov {\n        inPrivateTransferMode = _inPrivateTransferMode;\n    }\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n\n    function addNonStakingAccount(address _account) external onlyAdmin {\n        require(!nonStakingAccounts[_account], Errors.BASETOKEN_ACCOUNT_ALREADY_MARKED);\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = true;\n        nonStakingSupply = nonStakingSupply.add(balances[_account]);\n    }\n\n    function removeNonStakingAccount(address _account) external onlyAdmin {\n        require(nonStakingAccounts[_account], Errors.BASETOKEN_ACCOUNT_NOT_MARKED);\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = false;\n        nonStakingSupply = nonStakingSupply.sub(balances[_account]);\n    }\n\n    function recoverClaim(address _account, address _receiver) external onlyAdmin {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(_account, _receiver);\n        }\n    }\n\n    function claim(address _receiver) external {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(msg.sender, _receiver);\n        }\n    }\n\n    function totalStaked() external view override returns (uint256) {\n        return totalSupply.sub(nonStakingSupply);\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function stakedBalance(address _account) external view override returns (uint256) {\n        if (nonStakingAccounts[_account]) {\n            return 0;\n        }\n        return balances[_account];\n    }\n\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n        if (isHandler[msg.sender]) {\n            _transfer(_sender, _recipient, _amount);\n            return true;\n        }\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, Errors.BASETOKEN_TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE);\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), Errors.BASETOKEN_MINT_TO_THE_ZERO_ADDRESS);\n\n        _updateRewards(_account);\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), Errors.BASETOKEN_BURN_FROM_THE_ZERO_ADDRESS);\n\n        _updateRewards(_account);\n\n        balances[_account] = balances[_account].sub(_amount, Errors.BASETOKEN_BURN_AMOUNT_EXCEEDS_BALANCE);\n        totalSupply = totalSupply.sub(_amount);\n\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), Errors.BASETOKEN_TRANSFER_FROM_THE_ZERO_ADDRESS);\n        require(_recipient != address(0), Errors.BASETOKEN_TRANSFER_TO_THE_ZERO_ADDRESS);\n\n        if (inPrivateTransferMode) {\n            require(isHandler[msg.sender], Errors.BASETOKEN_MSG_SENDER_NOT_WHITELISTED);\n        }\n\n        _updateRewards(_sender);\n        _updateRewards(_recipient);\n\n        balances[_sender] = balances[_sender].sub(_amount, Errors.BASETOKEN_TRANSFER_AMOUNT_EXCEEDS_BALANCE);\n        balances[_recipient] = balances[_recipient].add(_amount);\n\n        if (nonStakingAccounts[_sender]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n        if (nonStakingAccounts[_recipient]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n\n        emit Transfer(_sender, _recipient, _amount);\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), Errors.BASETOKEN_APPROVE_FROM_THE_ZERO_ADDRESS);\n        require(_spender != address(0), Errors.BASETOKEN_APPROVE_TO_THE_ZERO_ADDRESS);\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _updateRewards(address _account) private {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).updateRewards(_account);\n        }\n    }\n}\n"
    },
    "contracts/tokens/base/MintableBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./BaseToken.sol\";\nimport \"../interfaces/IMintable.sol\";\nimport \"../../libraries/Errors.sol\";\n\ncontract MintableBaseToken is BaseToken, IMintable {\n    mapping(address => bool) public override isMinter;\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public BaseToken(_name, _symbol, _initialSupply) {\n    }\n    modifier onlyMinter() {\n        require(isMinter[msg.sender], Errors.MINTABLEBASETOKEN_FORBIDDEN);\n        _;\n    }\n    function setMinter(address _minter, bool _isActive) external override onlyGov {\n        isMinter[_minter] = _isActive;\n    }\n\n    function mint(address _account, uint256 _amount) external override onlyMinter {\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override onlyMinter {\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/tokens/base/YieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../../core/storage/YieldTokenStorage.sol\";\nimport \"../../libraries/Errors.sol\";\n\ncontract YieldToken is YieldTokenStorage {\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public {\n        name = _name;\n        symbol = _symbol;\n        gov = msg.sender;\n        admins[msg.sender] = true;\n        _mint(msg.sender, _initialSupply);\n    }\n    function addAdmin(address _account) external onlyGov {\n        admins[_account] = true;\n    }\n\n    function removeAdmin(address _account) external override onlyGov {\n        admins[_account] = false;\n    }\n\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function addNonStakingAccount(address _account) external onlyAdmin {\n        require(!nonStakingAccounts[_account], Errors.YIELDTOKEN_ACCOUNT_ALREADY_MARKED);\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = true;\n        nonStakingSupply = nonStakingSupply.add(balances[_account]);\n    }\n\n    function removeNonStakingAccount(address _account) external onlyAdmin {\n        require(nonStakingAccounts[_account], Errors.YIELDTOKEN_ACCOUNT_NOT_MARKED);\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = false;\n        nonStakingSupply = nonStakingSupply.sub(balances[_account]);\n    }\n\n    function recoverClaim(address _account, address _receiver) external onlyAdmin {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(_account, _receiver);\n        }\n    }\n\n    function claim(address _receiver) external {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(msg.sender, _receiver);\n        }\n    }\n    /* settings*/\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setInfo(string memory _name, string memory _symbol) external onlyGov {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function setYieldTrackers(address[] memory _yieldTrackers) external onlyGov {\n        yieldTrackers = _yieldTrackers;\n    }\n\n    function setInWhitelistMode(bool _inWhitelistMode) external onlyGov {\n        inWhitelistMode = _inWhitelistMode;\n    }\n\n    function setWhitelistedHandler(address _handler, bool _isWhitelisted) external onlyGov {\n        whitelistedHandlers[_handler] = _isWhitelisted;\n    }\n    /* views */\n    function totalStaked() external view override returns (uint256) {\n        return totalSupply.sub(nonStakingSupply);\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function stakedBalance(address _account) external view override returns (uint256) {\n        if (nonStakingAccounts[_account]) {\n            return 0;\n        }\n        return balances[_account];\n    }\n\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, Errors.YIELDTOKEN_TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE);\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n    /*internal */\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), Errors.YIELDTOKEN_MINT_TO_THE_ZERO_ADDRESS);\n        _updateRewards(_account);\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), Errors.YIELDTOKEN_BURN_FROM_THE_ZERO_ADDRESS);\n        _updateRewards(_account);\n        balances[_account] = balances[_account].sub(_amount, Errors.YIELDTOKEN_BURN_AMOUNT_EXCEEDS_BALANCE);\n        totalSupply = totalSupply.sub(_amount);\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), Errors.YIELDTOKEN_TRANSFER_FROM_THE_ZERO_ADDRESS);\n        require(_recipient != address(0), Errors.YIELDTOKEN_TRANSFER_TO_THE_ZERO_ADDRESS);\n        if (inWhitelistMode) {\n            require(whitelistedHandlers[msg.sender], Errors.YIELDTOKEN_MSG_SENDER_NOT_WHITELISTED);\n        }\n        _updateRewards(_sender);\n        _updateRewards(_recipient);\n        balances[_sender] = balances[_sender].sub(_amount, Errors.YIELDTOKEN_TRANSFER_AMOUNT_EXCEEDS_BALANCE);\n        balances[_recipient] = balances[_recipient].add(_amount);\n        if (nonStakingAccounts[_sender]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n        if (nonStakingAccounts[_recipient]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n        emit Transfer(_sender, _recipient, _amount);\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), Errors.YIELDTOKEN_APPROVE_FROM_THE_ZERO_ADDRESS);\n        require(_spender != address(0), Errors.YIELDTOKEN_APPROVE_TO_THE_ZERO_ADDRESS);\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _updateRewards(address _account) private {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).updateRewards(_account);\n        }\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IBaseToken {\n    function totalStaked() external view returns (uint256);\n    function stakedBalance(address _account) external view returns (uint256);\n    function removeAdmin(address _account) external;\n    function setInPrivateTransferMode(bool _inPrivateTransferMode) external;\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}"
    },
    "contracts/tokens/interfaces/IMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IMintable {\n    function isMinter(address _account) external returns (bool);\n    function setMinter(address _minter, bool _isActive) external;\n    function mint(address _account, uint256 _amount) external;\n    function burn(address _account, uint256 _amount) external;\n}"
    },
    "contracts/tokens/interfaces/IWETH.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"
    },
    "contracts/tokens/interfaces/IYieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IYieldToken {\n    function totalStaked() external view returns (uint256);\n    function stakedBalance(address _account) external view returns (uint256);\n    function removeAdmin(address _account) external;\n}"
    },
    "contracts/tokens/interfaces/IYieldTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IYieldTracker {\n    function claim(address _account, address _receiver) external returns (uint256);\n    function updateRewards(address _account) external;\n    function getTokensPerInterval() external view returns (uint256);\n    function claimable(address _account) external view returns (uint256);\n}"
    },
    "contracts/tokens/interfaces/IZKUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IZKUSD {\n    function addVault(address _vault) external;\n    function removeVault(address _vault) external;\n    function mint(address _account, uint256 _amount) external;\n    function burn(address _account, uint256 _amount) external;\n}"
    },
    "contracts/tokens/v2/ZKHLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../base/MintableBaseToken.sol\";\nimport \"../../libraries/Constants.sol\";\ncontract ZKHLP is MintableBaseToken {\n    constructor() public MintableBaseToken(Constants.ZKDLP_TOKEN_NAME, Constants.ZKDLP_TOKEN_SYMBOL, 0) {\n    }\n    function id() external pure returns (string memory _name) {\n        return \"ZKHLP\";\n    }\n}\n"
    },
    "contracts/tokens/ZKDLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./base/MintableBaseToken.sol\";\nimport \"../libraries/Constants.sol\";\ncontract ZKDLP is MintableBaseToken {\n    constructor() public MintableBaseToken(Constants.ZKDLP_TOKEN_NAME, Constants.ZKDLP_TOKEN_SYMBOL, 0) {\n    }\n    function id() external pure returns (string memory _name) {\n        return Constants.ZKDLP_ID;\n    }\n}\n"
    },
    "contracts/tokens/ZKDX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./base/MintableBaseToken.sol\";\nimport \"../libraries/Constants.sol\";\ncontract ZKDX is MintableBaseToken {\n    constructor() public MintableBaseToken(Constants.ZKDX_TOKEN_NAME, Constants.ZKDX_TOKEN_SYMBOL, 0) {\n    }\n    function id() external pure returns (string memory _name) {\n        return Constants.ZKDX_ID;\n    }\n}\n"
    },
    "contracts/tokens/ZKUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./interfaces/IZKUSD.sol\";\nimport \"../libraries/Constants.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"./base/YieldToken.sol\";\n\ncontract ZKUSD is YieldToken, IZKUSD {\n    mapping(address => bool) public vaults;\n    modifier onlyVault() {\n        require(vaults[msg.sender], Errors.ZKUSD_FORBIDDEN);\n        _;\n    }\n    constructor(address _vault) public YieldToken(Constants.ZKUSD_TOKEN_NAME, Constants.ZKUSD_TOKEN_SYMBOL, 0) {\n        vaults[_vault] = true;\n    }\n    function addVault(address _vault) external override onlyGov {\n        vaults[_vault] = true;\n    }\n\n    function removeVault(address _vault) external override onlyGov {\n        vaults[_vault] = false;\n    }\n\n    function mint(address _account, uint256 _amount) external override onlyVault {\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override onlyVault {\n        _burn(_account, _amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}